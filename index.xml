<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>HyperMake</title>
    <link>http://evo-cloud.github.com/hmake/</link>
    <description>Recent content on HyperMake</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="http://evo-cloud.github.com/hmake/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>A HyperMake Project</title>
      <link>http://evo-cloud.github.com/hmake/tutor/project/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/tutor/project/</guid>
      <description>Project Layout A HyperMake project requires one HyperMake file in root directory of the project (The file name can be overridden using --file|-f, see Command Line for details). The command hmake can be invoked in any sub-directory of the project and it will look up HyperMake to determine the root of project.
Similar to a Makefile, HyperMake defines targets with dependencies (see File Format). To better organize the targets, it&amp;rsquo;s possible to break targets into multiple files.</description>
    </item>
    
    <item>
      <title>Command Line</title>
      <link>http://evo-cloud.github.com/hmake/references/commandline/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/references/commandline/</guid>
      <description>hmake [OPTIONS] [TARGETS]  There&amp;rsquo;s no specific order between OPTIONS and TARGETS. All OPTIONS starts with hyphen - while TARGETS doesn&amp;rsquo;t.
Common Unix command line option parsing rule is adopted:
  A short option starts with a single hyphen and then a single letter (e.g. -C); it may have a corresponding long option which starts with a double hyphen followed by a word (or a few words concated with hyphen) (e.</description>
    </item>
    
    <item>
      <title>Installation</title>
      <link>http://evo-cloud.github.com/hmake/quickguide/install/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/quickguide/install/</guid>
      <description>Install Docker Install Docker, version 1.12.3 or above is required.
Run
docker version  and make sure it shows both client and server versions correctly.
Docker Compose (Optional) Install docker-compose if you want to use compose property in targets.
Install HyperMake For Mac brew tap evo-cloud/toolkit # only do this once brew install hmake  Or download and extract the binary directly
curl -s https://github.com/evo-cloud/hmake/releases/download/v1.3.1/hmake-darwin-amd64.tar.gz | sudo tar -C /usr/local/bin -zx  For Linux curl -s https://github.</description>
    </item>
    
    <item>
      <title>File Format</title>
      <link>http://evo-cloud.github.com/hmake/references/fileformat/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/references/fileformat/</guid>
      <description>for wrapper mode, please refer to Wrapper Mode
File HyperMake must be present in root directory of the project tree. Command hmake can be invoked in any sub-directories inside the project tree and it will locate the root of project by looking up HyperMake. Additional files must be named as *.hmake for being referenced in includes section. All these files share the same format.
In HyperMake or *.hmake, define the following things:</description>
    </item>
    
    <item>
      <title>Hello World</title>
      <link>http://evo-cloud.github.com/hmake/quickguide/helloworld/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/quickguide/helloworld/</guid>
      <description>A Simple Project Let&amp;rsquo;s make a simple Hello World C++ project, and see how HyperMake can help.
Here&amp;rsquo;s the project directory layout:
ProjectRoot | +--inc/ +--src/ +--hello.cpp  In hello.cpp:
#include &amp;lt;iostream&amp;gt; int main(int argc, char *argv[]) { std::cout &amp;lt;&amp;lt; &amp;quot;Hello World!&amp;quot; &amp;lt;&amp;lt; std::endl; return 0; }  To build it, use g++ -o hello src/hello.cpp. Probably you will need to run sudo apt install g++ first on Debian/Ubuntu if you&amp;rsquo;ve never installed the toolchain.</description>
    </item>
    
    <item>
      <title>Target Execution</title>
      <link>http://evo-cloud.github.com/hmake/tutor/targetexec/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/tutor/targetexec/</guid>
      <description>For full specification of all properties, please refer to
 File Format Docker Driver  How Target Executes A target always executes inside Docker container.
--- format: hypermake.v0 name: hello description: The Hello World Project targets: build: description: build hello binary image: &#39;gcc:4.9&#39; cmds: - g++ -o hello src/hello.cpp - strip hello  In the above example, a container is created using image gcc:4.9 as specified by property image. And lines in cmds are merged into a shell script .</description>
    </item>
    
    <item>
      <title>Build Docker Image</title>
      <link>http://evo-cloud.github.com/hmake/tutor/buildimage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/tutor/buildimage/</guid>
      <description>It&amp;rsquo;s simple and straight-forward to build Docker images using hmake.
Use Docker build --- format: hypermake.v0 name: build-sample targets: build-image: description: build docker image build: dir-contains-Dockerfile image: &#39;my-image:tag&#39; tags: - &#39;my-image1:tag1&#39; - &#39;my-image2:tag2&#39;  Specify property build to run docker build for the target. The value can be a path to a directory containing Dockerfile, or path including filename. If filename is included, it&amp;rsquo;s not necessary to be Dockerfile, hmake will take care of the right command line arguments to docker build.</description>
    </item>
    
    <item>
      <title>Docker Driver</title>
      <link>http://evo-cloud.github.com/hmake/references/dockerdrv/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/references/dockerdrv/</guid>
      <description>This execution driver interprets commands or scripts and run inside docker container using specified image. The driver uses docker run to start the container, not using Docker REST API, so docker CLI is required.
Properties  script: a multi-line string represents a full script to execute inside the container; E.g.  targets: sample: script: | #!/bin/bash echo &#39;This is a bash script&#39; sample1: script: | #!/usr/bin/env perl print &amp;quot;a perl script&amp;quot;   cmds: when script is not specified, this is a list of commands to execute for the target; E.</description>
    </item>
    
    <item>
      <title>Push Docker Image</title>
      <link>http://evo-cloud.github.com/hmake/tutor/pushimage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/tutor/pushimage/</guid>
      <description>hmake provides built-in support to push docker image to a remote registry.
--- format: hypermake.v0 name: push-sample targets: build-image: description: build docker image build: Dockerfile image: &#39;myimage:tag&#39; tags: - &#39;registry:5000/namespace/myimage:tag&#39; - &#39;registry1/namespace/myimage:tag&#39; push-image: description: push docker images after: - build-image push: - &#39;registry:5000/namespace/myimage:tag&#39; - &#39;registry1/namespace/myimage:tag&#39;  The property push specifies which images to push. hmake calls docker push locally to push the images, so make sure the credentials are stored using docker login if the registry requires authentication.</description>
    </item>
    
    <item>
      <title>Docker Compose</title>
      <link>http://evo-cloud.github.com/hmake/tutor/compose/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/tutor/compose/</guid>
      <description>hmake supports docker-compose out-of-box, using property compose.
--- format: hypermake.v0 name: compose-sample targets: build: description: build from source code cmds: - ./build.sh artifacts: - out/service/Dockerfile - out/service/service.bin - out/service-compose/docker-compose.yml pack: description: pack as docker image after: - build build: out/service image: &#39;myservice:latest&#39; start: description: start built service in background after: - pack compose: out/service-compose test: description: test against service after: - start link: - &#39;service:service&#39; cmds: - ./test.sh  Please refer to Background Target, Docker Driver for details.</description>
    </item>
    
    <item>
      <title>Exec(Debug) Mode</title>
      <link>http://evo-cloud.github.com/hmake/tutor/execmode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/tutor/execmode/</guid>
      <description>exec mode allows execution of arbitrary command inside the container under the context of the specified target. It&amp;rsquo;s very useful to debug the environment.
Overview --- format: hypermake.v0 targets: build: description: build the source code cmds: - ./build.sh env: - FLAG=1 test: description: run test cmds: - ./test.sh settings: exec-target: build docker: image: &#39;ubuntu:latest&#39;  Sometimes, developers need to get into the execution environment of a target to find out what goes wrong.</description>
    </item>
    
    <item>
      <title>Command Mode</title>
      <link>http://evo-cloud.github.com/hmake/tutor/commandmode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/tutor/commandmode/</guid>
      <description>Overview Similar to make, the command line arguments are interpreted as targets name for hmake. In addition to that, hmake introduces a special type of targets - commands. When these targets are invoked, the command line arguments will be passed through to the target as arguments.
See File Format for details.
--- format: hypermake.v0 targets: build: description: build the source code cmds: - ./build.sh commands: pack-for: description: pack for specified target after: - build cmds: - &#39;.</description>
    </item>
    
    <item>
      <title>Map Credentials</title>
      <link>http://evo-cloud.github.com/hmake/tutor/mapcreds/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/tutor/mapcreds/</guid>
      <description>Problem Many CLI tools like docker, aws-cli, gcloud etc stores credentials in user&amp;rsquo;s home directory. When build directly from the host, there&amp;rsquo;s no problem accessing these services. However, using hmake, build runs inside container which doesn&amp;rsquo;t have the right credentials, and will fail.
Solution Here&amp;rsquo;s a commonly used practice to map credentials from local home directory.
--- format: hypermake.v0 name: map-credentials targets: build: description: build source code cmds: - .</description>
    </item>
    
    <item>
      <title>Target Expansion</title>
      <link>http://evo-cloud.github.com/hmake/tutor/targetexp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/tutor/targetexp/</guid>
      <description>It&amp;rsquo;s quite common targets are defined similarly with very small difference. For example, a build target which builds for different CPU architectures, the only difference can be the name passing to the build script.
--- format: hypermake.v0 name: expand-sample targets: hmake-linux-amd64: description: static linked hmake binary for linux-amd64 after: - vendor watches: - &#39;**/**/*.go&#39; - build.sh cmds: - ./build.sh linux amd64 artifacts: - bin/linux/amd64/hmake - bin/hmake-linux-amd64.tar.gz - bin/hmake-linux-amd64.tar.gz.sha256sum hmake-linux-arm: description: static linked hmake binary for linux-arm after: - vendor watches: - &#39;**/**/*.</description>
    </item>
    
    <item>
      <title>Wrapper Mode</title>
      <link>http://evo-cloud.github.com/hmake/tutor/wrappermode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/tutor/wrappermode/</guid>
      <description>I have a project using Makefile; I don&amp;rsquo;t want to learn HyperMake. But building in container is very appealing to me.
hmake provides a special wrapper mode for legacy projects.
A Simple and Quick Start echo &#39;#hmake-wrapper gcc:4.9&#39; &amp;gt;HyperMake  Now hmake becomes a wrapper of make
hmake target1 target2  is equivalent to
make target1 target2  but inside a container created from gcc:4.9.
Specification In wrapper mode, HyperMake may contain one or more lines.</description>
    </item>
    
    <item>
      <title>FAQ</title>
      <link>http://evo-cloud.github.com/hmake/tutor/faq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/tutor/faq/</guid>
      <description>Q: Why I can&amp;rsquo;t git clone private repositories?
A: HyperMake runs the build inside containers which may not have the right SSH keys or credentials. There&amp;rsquo;re two options:
 Mapping ~/.ssh into the container using volumes property:  volumes: - &#39;~/.ssh:/src/.ssh:ro&#39;   Mapping ~/.netrc into the container:  first, create a file ~/.netrc. See the manual for the format and content. E.g.
machine github.com protocol https login username password password  Then use volumes property to map into the container.</description>
    </item>
    
  </channel>
</rss>