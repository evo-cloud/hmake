<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>HyperMake</title>
    <link>http://evo-cloud.github.com/hmake/</link>
    <description>Recent content on HyperMake</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://evo-cloud.github.com/hmake/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title></title>
      <link>http://evo-cloud.github.com/hmake/README/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/README/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;It&amp;rsquo;s a build tool which builds projects &lt;strong&gt;without pre-requisites&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/evo-cloud/hmake/master/site/gh-pages/static/images/arm-hello.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Pains&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Preparing building environment may take days&lt;/li&gt;
&lt;li&gt;Solving conflicts and incorrect versions of dependencies is painful&lt;/li&gt;
&lt;li&gt;Writing long and complicated building instructions when shipping the work&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Heals&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Forget about environment setup, what needed are only&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A running &lt;a href=&#34;https://www.docker.com&#34;&gt;docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hmake&lt;/code&gt; executable in &lt;code&gt;PATH&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;HyperMake helps you build projects instantly and consistently without installing
pre-requisites in your local environment.
It uses containers to build projects, all pre-requisites are installed cleanly
and consistently inside the container.&lt;/p&gt;

&lt;p&gt;Please read &lt;a href=&#34;http://evo-cloud.github.com/hmake/hmake/docs/UseCases/&#34;&gt;Use Cases&lt;/a&gt; to find out how HyperMake helps.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Features&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Brings back the experience of &lt;em&gt;make&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Selectively build targets on demand&lt;/li&gt;
&lt;li&gt;Build in parallel&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;HyperMake Server&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/evo-cloud/hmaked&#34;&gt;HyperMake Server&lt;/a&gt; is a CI/CD solution for
projects built with HyperMake.
It provides consistent environments for development, testing, integration and
deployment.&lt;/p&gt;

&lt;h2 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h2&gt;

&lt;p&gt;Knowledge required as a user:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Docker: &lt;a href=&#34;http://www.docker.com&#34;&gt;http://www.docker.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Very basic Unix shell and command line tools&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As an author of HyperMake files:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;YAML: &lt;a href=&#34;http://yaml.org&#34;&gt;http://yaml.org&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;installation&#34;&gt;Installation&lt;/h3&gt;

&lt;p&gt;Assume &lt;a href=&#34;http://www.docker.com&#34;&gt;Docker&lt;/a&gt; is already installed, and make sure it&amp;rsquo;s
running properly.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;TIPS&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;When using &lt;code&gt;docker-machine&lt;/code&gt;, many people encountered the issue docker complains
unable to connect to docker daemon. The cause is the environment variables are
not populated properly in current shell. Type the following commands:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# if you are using bash
eval $(docker-machine env MACHINE-NAME)
docker version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Make sure &lt;code&gt;docker version&lt;/code&gt; is able to show both versions of client and server,
otherwise, docker may not work properly.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now we can move on install &lt;code&gt;hmake&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;On Mac OS X, using Homebrew is the simplest way&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;brew tap evo-cloud/toolkit  # only do this once
brew install hmake
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternatively, download from Github &lt;a href=&#34;https://github.com/evo-cloud/hmake/releases&#34;&gt;releases&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -s https://github.com/evo-cloud/hmake/releases/download/v1.3.0/hmake-linux-amd64.tar.gz | sudo tar -C /usr/local/bin -zx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you are on Mac OS, change &lt;code&gt;linux&lt;/code&gt; above to &lt;code&gt;darwin&lt;/code&gt;.
For Windows, change &lt;code&gt;linux&lt;/code&gt; to &lt;code&gt;windows&lt;/code&gt; and unpack the binary to some folder in
&lt;code&gt;%PATH%&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now do &lt;code&gt;hmake --version&lt;/code&gt; to verify if it&amp;rsquo;s properly installed.&lt;/p&gt;

&lt;h3 id=&#34;do-something-funny&#34;&gt;Do Something Funny&lt;/h3&gt;

&lt;p&gt;For the first time using hmake, let&amp;rsquo;s do something funny - cross compile Linux
kernel without installing anything, even on Mac OS/Windows!&lt;/p&gt;

&lt;p&gt;Checkout the examples in &lt;a href=&#34;https://github.com/evo-cloud/hmake&#34;&gt;hmake&lt;/a&gt; repository&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone https://github.com/evo-cloud/hmake
cd hmake/examples/linux
hmake -sv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it! You get Linux kernel for both x86_64 and ARMv7 (vexpress board) in
a while.&lt;/p&gt;

&lt;p&gt;See &lt;a href=&#34;http://evo-cloud.github.com/hmake/hmake/examples/linux/README/&#34;&gt;README&lt;/a&gt; for details.&lt;/p&gt;

&lt;h2 id=&#34;how-it-works&#34;&gt;How It Works&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;hmake&lt;/em&gt; works in a very simple way by running the commands of each target inside
the specified Docker container which already has pre-requisites installed.
The root directory of project tree is mapped into the container under a certain
path which can be customized, and the commands is able to access files inside
the project and can also produce output files into the project tree.&lt;/p&gt;

&lt;h3 id=&#34;state-directory&#34;&gt;State Directory&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;hmake&lt;/em&gt; creates a state directory &lt;code&gt;$HMAKE_PROJECT_DIR/.hmake&lt;/code&gt;
(see &lt;a href=&#34;http://evo-cloud.github.com/hmake/hmake/docs/FileFormat/&#34;&gt;File Format&lt;/a&gt; for the details of environment variables)
to store logs and state files.
The output (stdout and stderr combined) of each target is stored in files &lt;code&gt;TARGET.log&lt;/code&gt;.
Debug log is stored as &lt;code&gt;hmake.debug.log&lt;/code&gt;.
Summary file is stored as &lt;code&gt;hmake.summary.json&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;documents&#34;&gt;Documents&lt;/h2&gt;

&lt;p&gt;Please read the following documents if more detailed information is needed&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://evo-cloud.github.com/hmake/hmake/docs/QuickStart/&#34;&gt;Quick Start&lt;/a&gt; is a step-by-step guide to write your first
HyperMake file for your project;&lt;/li&gt;
&lt;li&gt;References are list of specifications including

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://evo-cloud.github.com/hmake/hmake/docs/FileFormat/&#34;&gt;File Format&lt;/a&gt; defines the format of &lt;em&gt;hmake&lt;/em&gt; files;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://evo-cloud.github.com/hmake/hmake/docs/CommandLine/&#34;&gt;Command line&lt;/a&gt; specification;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://evo-cloud.github.com/hmake/hmake/docs/Contribute/&#34;&gt;Contributing&lt;/a&gt; is a guideline for people who want to
contribute to this project.&lt;/li&gt;
&lt;li&gt;Examples are always helpful

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://evo-cloud.github.com/hmake/hmake/examples/arm-hello/README/&#34;&gt;Wrap Hello World for ARM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://evo-cloud.github.com/hmake/hmake/examples/linux/README/&#34;&gt;Cross Compile Linux kernel&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://evo-cloud.github.com/hmake/hmake/docs/FAQ/&#34;&gt;FAQ and Best Practices&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;supported-platform-and-software&#34;&gt;Supported Platform and Software&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;docker 1.9 and above (1.9 - 1.11 tested)&lt;/li&gt;
&lt;li&gt;Linux (Ubuntu 14.04 tested)&lt;/li&gt;
&lt;li&gt;Mac OS X 10.9 and above (10.9, 10.11 tested)&lt;/li&gt;
&lt;li&gt;Windows 7 SP1&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;limits&#34;&gt;Limits&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;On Mac OS X, the project tree must be under &lt;code&gt;/Users&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;On Windows, the project tree must be under &lt;code&gt;C:\Users&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker-machine&lt;/code&gt; is required on Mac OS X and Windows;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker-machine&lt;/code&gt; is not supported on Linux;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;See &lt;a href=&#34;http://evo-cloud.github.com/hmake/hmake/docs/DockerDriver/&#34;&gt;Docker Driver&lt;/a&gt; for details.&lt;/p&gt;

&lt;h4 id=&#34;issues&#34;&gt;Issues&lt;/h4&gt;

&lt;p&gt;If you meet any issues or have specific problems, please check
&lt;a href=&#34;http://evo-cloud.github.com/hmake/hmake/docs/FAQ/&#34;&gt;FAQ and Best Practices&lt;/a&gt; if there&amp;rsquo;s already a solution.
Feel free to email the MAINTAINERS for any questions.&lt;/p&gt;

&lt;h2 id=&#34;license&#34;&gt;License&lt;/h2&gt;

&lt;p&gt;MIT&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://evo-cloud.github.com/hmake/docs/CommandLine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/docs/CommandLine/</guid>
      <description>

&lt;h1 id=&#34;hypermake-command-line&#34;&gt;HyperMake Command Line&lt;/h1&gt;

&lt;h2 id=&#34;usage&#34;&gt;Usage&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;hmake [OPTIONS] [TARGETS]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s no specific order between &lt;code&gt;OPTIONS&lt;/code&gt; and &lt;code&gt;TARGETS&lt;/code&gt;. All &lt;code&gt;OPTIONS&lt;/code&gt; starts
with hyphen &lt;code&gt;-&lt;/code&gt; while &lt;code&gt;TARGETS&lt;/code&gt; doesn&amp;rsquo;t.&lt;/p&gt;

&lt;h2 id=&#34;option-parsing-rules&#34;&gt;Option Parsing Rules&lt;/h2&gt;

&lt;p&gt;Common Unix command line option parsing rule is adopted:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A short option starts with a single hyphen and then a single letter
(e.g. &lt;code&gt;-C&lt;/code&gt;);
it may have a corresponding long option which starts with a double hyphen
followed by a word (or a few words concated with hyphen)
(e.g. &lt;code&gt;--chdir&lt;/code&gt;, &lt;code&gt;--this-is-a-multi-word-opt&lt;/code&gt;);&lt;/li&gt;
&lt;li&gt;The value after a short option is provided as a separated argument
(after a space, e.g. &lt;code&gt;-C /tmp/proj&lt;/code&gt;);
for long option, the value follows directly with &lt;code&gt;=&lt;/code&gt; in the same argument
(e.g. &lt;code&gt;--chdir=/tmp/proj&lt;/code&gt;);&lt;/li&gt;
&lt;li&gt;Some option can be specified multiple times to provide a list or a map
(e.g.&lt;br&gt;
&lt;em&gt;list&lt;/em&gt;: &lt;code&gt;--include=a.hmake --include=b.hmake&lt;/code&gt; or &lt;code&gt;-I a.hmake -I b.hmake&lt;/code&gt;;&lt;br&gt;
&lt;em&gt;map&lt;/em&gt;: &lt;code&gt;--define=ARCH=x86_64 --define=OS=linux&lt;/code&gt; or &lt;code&gt;-D ARCH=x86_64 -D OS=linux&lt;/code&gt;
);&lt;/li&gt;
&lt;li&gt;Bool options can be specified without value as &lt;code&gt;true&lt;/code&gt; or prefixed by &lt;code&gt;no-&lt;/code&gt; as
&lt;code&gt;false&lt;/code&gt; (e.g. &lt;code&gt;--verbose&lt;/code&gt; for &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;--no-verbose&lt;/code&gt; for &lt;code&gt;false&lt;/code&gt;);
It can also be specified with a value in the long option format
(e.g. &lt;code&gt;--verbose=true&lt;/code&gt; or &lt;code&gt;--verbose=false&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;options&#34;&gt;Options&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--chdir=PATH, -C PATH&lt;/code&gt;: Chdir to specified PATH first before doing anything&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--file=FILE, -f FILE&lt;/code&gt;: Override the default project file name &lt;code&gt;HyperMake&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--include=FILE, -I FILE&lt;/code&gt;: Include additional files (must be relative path under project root), can be specified multiple times&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--property=key=value, -P key=value&lt;/code&gt;: Define property in global &lt;code&gt;settings&lt;/code&gt; section, &lt;code&gt;key&lt;/code&gt; may include &lt;code&gt;.&lt;/code&gt; to specify the hierarchy&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--parallel=N, -p N&lt;/code&gt;: Set maximum number of targets executed in parallel, 0 for auto, -1 for unlimited&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--rebuild-all, -R&lt;/code&gt;: Force rebuild all needed targets&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--rebuild-target TARGET, -r TARGET&lt;/code&gt;: Force rebuild specified target, this can repeat&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--rebuild, -b&lt;/code&gt;: Force rebuild targets specified on command line&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--skip TARGET, -S TARGET&lt;/code&gt;: Skip specified target (mark as Skipped), this can repeat&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--exec, -x&lt;/code&gt;: Execute a shell command in the context of a target.
The target name must be specified in &lt;code&gt;settings.exec-target&lt;/code&gt; or use &lt;code&gt;--exec-with=TARGET&lt;/code&gt;.
It&amp;rsquo;s extremely useful to run arbitrary command in the context of a target.
It should come as the last option, as the rest command-line arguments will be
treated as command.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;  hmake -x go version
  hmake -x   # enter an interactive shell inside the container
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The commands parsing after &lt;code&gt;-x&lt;/code&gt; is directly executed by &lt;code&gt;execvp&lt;/code&gt; system call,
  not a command to be parsed by shell. So shell syntax like &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; won&amp;rsquo;t work.&lt;/p&gt;

&lt;p&gt;To run as a shell command&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;  hmake -x /bin/sh -c &#39;go version || echo &amp;quot;go version failed&amp;quot;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--exec-with=TARGET, -X TARGET&lt;/code&gt;: Explicitly specify the target for &lt;code&gt;--exec&lt;/code&gt; instead of
fetching from &lt;code&gt;settings.exec-target&lt;/code&gt;.
As it implies &lt;code&gt;--exec&lt;/code&gt;, it should come as the last option.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;  hmake --exec-with=vendor go version
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--json&lt;/code&gt;: Dump execution events to stdout each encoded in single line json&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--summary, -s&lt;/code&gt;: Show execution summary before exit&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--quiet, -q&lt;/code&gt;: Suppress output from each target&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--rcfile|--no-rcfile&lt;/code&gt;: Load .hmakerc inside project directories, default is true&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--color|--no-color&lt;/code&gt;: Explicitly specify print with color/no-color&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--emoji|--no-emoji&lt;/code&gt;: Explicitly specify print with emoji/no-emoji&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--no-debug-log&lt;/code&gt;: Disable writing debug log to &lt;code&gt;hmake.debug.log&lt;/code&gt; in hmake state directory&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--show-summary&lt;/code&gt;: When specified, print previous execution summary and exit&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--targets&lt;/code&gt;: When specified, print list of target names and exit&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--dryrun&lt;/code&gt;: When specified, run targets as normal but without invoking execution drivers (simply mark task Success)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--version&lt;/code&gt;: When specified, print version and exit&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The parsing of options stops when &lt;code&gt;--&lt;/code&gt; is encountered. The rest of arguments will be
treated as target names. Except &lt;code&gt;--exec&lt;/code&gt;/&lt;code&gt;--exec-with&lt;/code&gt; already implies end of
options parsing, &lt;code&gt;--&lt;/code&gt; should not be used.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: &lt;code&gt;--exec&lt;/code&gt;/&lt;code&gt;--exec-with&lt;/code&gt; doesn&amp;rsquo;t affect the last execution result of the
target, though it displays the result and updates the summary. So the target
may still be skipped next time if nothing changed.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;exit-code&#34;&gt;Exit Code&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;0: Success&lt;/li&gt;
&lt;li&gt;1: One or more targets failed&lt;/li&gt;
&lt;li&gt;2: Incorrect usage&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://evo-cloud.github.com/hmake/docs/Contribute/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/docs/Contribute/</guid>
      <description>

&lt;h1 id=&#34;guidelines-for-contributing-to-hypermake&#34;&gt;Guidelines for Contributing to HyperMake&lt;/h1&gt;

&lt;p&gt;Thanks for using &lt;em&gt;HyperMake&lt;/em&gt; and welcome to contribute any features/patches back
to this project!&lt;/p&gt;

&lt;h2 id=&#34;before-you-start&#34;&gt;Before You Start&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Make sure you understand the features of &lt;em&gt;HyperMake&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Look at &lt;a href=&#34;https://github.com/evo-cloud/hmake/issues&#34;&gt;Github Issues&lt;/a&gt; to see if
your feature request/issue has already been submitted&lt;/li&gt;
&lt;li&gt;Be familiar with &lt;a href=&#34;http://golang.org&#34;&gt;Go development&lt;/a&gt; and &lt;a href=&#34;http://www.docker.com&#34;&gt;Docker&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;submit-an-issue&#34;&gt;Submit an Issue&lt;/h2&gt;

&lt;p&gt;An issue can be a feature request or a bug. If possible please put on the
corresponding labels &lt;code&gt;feature&lt;/code&gt;, &lt;code&gt;bug&lt;/code&gt;, &lt;code&gt;enhancement&lt;/code&gt; etc. And the maintainers
may alter the labels and put priority labels.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Features&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Please clearly define the feature with as more details as possible to help others
easily understand the feature. For example, describing the detailed operation
steps, listing the example usage (command line) will be great help.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Bugs&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;In the title, please briefly describe the problem.
In the comment, please follow the structures below:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Problem Description

Detailed problem description

# Environment

Platform: OS, version
Arch: CPU architecture
Version: hmake version

Other information...

# Reproduce Steps

Steps for reproducing the problem

# Attached Content

E.g. Content of your HyperMake file, project directory structure,
scripts when possible.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;submit-a-pull-request&#34;&gt;Submit a Pull Request&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Make sure there&amp;rsquo;s a corresponding issue submitted in
&lt;a href=&#34;https://github.com/evo-cloud/hmake/issues&#34;&gt;Github Issues&lt;/a&gt;, arbitrary pull
requests are unlikely to be accepted;&lt;/li&gt;
&lt;li&gt;Make sure your code has been well formatted, vetted/linted and documented;&lt;/li&gt;
&lt;li&gt;Include issue number in your short commit message (first line), like &lt;code&gt;#15&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;Tests must be included, depending on the change, End-to-End tests may be required;&lt;/li&gt;
&lt;li&gt;Make sure there&amp;rsquo;s a single commit.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;TIPS&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;To run format check, vet and lint, you can simply use&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hmake check -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To fix format, simply use&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go fmt -w DIR
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;dependencies-needed&#34;&gt;Dependencies Needed&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Git&lt;/li&gt;
&lt;li&gt;A Github account&lt;/li&gt;
&lt;li&gt;Go 1.6 or above: install from &lt;a href=&#34;http://golang.org&#34;&gt;golang.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;A list of Go dependencies:

&lt;ul&gt;
&lt;li&gt;gvt: &lt;code&gt;go get github.com/FiloSottile/gvt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ginkgo: &lt;code&gt;go get github.com/onsi/ginkgo/ginkgo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;gomega: &lt;code&gt;go get github.com/onsi/gomega&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;hugo: &lt;code&gt;go get github.com/spf13/hugo&lt;/code&gt;, if you want to generate sites&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;For format, vet and lint

&lt;ul&gt;
&lt;li&gt;go tools: &lt;code&gt;go get golang.org/x/tools/cmd/...&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;metalinter: &lt;code&gt;go get -v github.com/alecthomas/gometalinter &amp;amp;&amp;amp; gometalinter --install&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;steps-to-get-started&#34;&gt;Steps to Get Started&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Fork &lt;code&gt;github.com/evo-cloud/hmake&lt;/code&gt; to your own account (assume &lt;code&gt;dev&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Create a Go development environment, the following steps are recommended for
most people, especially for those new to Go:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;   mkdir -p ~/workspace/go
   cd ~/workspace/go
   export GOPATH=`pwd`
   export PATH=&amp;quot;$GOPATH/bin:$PATH&amp;quot;
   go get github.com/FiloSottile/gvt
   go get github.com/onsi/ginkgo/ginkgo
   go get github.com/onsi/gomega
   mkdir -p src/github.com/evo-cloud
   git clone git@github.com:dev/hmake src/github.com/evo-cloud/hmake
   cd src/github.com/evo-cloud/hmake
   gvt restore
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;Start developing&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;   cd ~/workspace/go/src/github.com/evo-cloud/hmake
   # and make sure environment variable GOPATH and PATH are properly set as above

   go build ./   # this will build ./hmake executable
   go install ./ # or if you want to install to $GOPATH/bin

   # make sure docker is running
   # if docker-machine is used (not for Linux)
   eval $(docker-machine env MACHINE-NAME)
   docker version # make sure both client and server versions are displayed

   ./hmake -sv # build all by default
   ./hmake check # check format, run lint
   ./hmake test # run tests
   ./hmake e2e # run end-to-end tests
   ./hmake cover # generate coverage

   # alternatively, use go directly
   go test ./test
   # or
   ginkgo ./test
   go test ./test/e2e
   # or
   ginkgo ./test/e2e
   go test -coverprofile=cover.out -coverpkg=./project ./test
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://evo-cloud.github.com/hmake/docs/DockerDriver/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/docs/DockerDriver/</guid>
      <description>

&lt;h1 id=&#34;the-docker-execution-driver&#34;&gt;The &lt;em&gt;docker&lt;/em&gt; Execution Driver&lt;/h1&gt;

&lt;p&gt;This execution driver interprets commands or scripts and run inside the specified
docker container.&lt;/p&gt;

&lt;h2 id=&#34;properties&#34;&gt;Properties&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;script&lt;/code&gt;: a multi-line string represents a full script to execute inside the
container;
E.g.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  targets:
      sample:
          script: |
              #!/bin/bash
              echo &#39;This is a bash script&#39;
      sample1:
          script: |
              #!/usr/bin/env perl
              print &amp;quot;a perl script&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cmds&lt;/code&gt;: when &lt;code&gt;script&lt;/code&gt; is not specified, this is a list of commands to execute
for the target; E.g.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  targets:
      sample:
          cmds:
              - mkdir -p bin
              - gcc -o bin/hello hello.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the list of commands is merged to generate a shell script:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;  #!/bin/sh
  set -e
  mkdir -p bin
  gcc -o bin/hello hello.c
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;env&lt;/code&gt;: a list of environment variables (the form &lt;code&gt;NAME=VALUE&lt;/code&gt;) to be used for
execution (the &lt;code&gt;-e&lt;/code&gt; option of &lt;code&gt;docker run&lt;/code&gt;); E.g.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  targets:
      sample:
          env:
              - ARCH=x86_64
              - OS=linux
              - RELEASE        # without =VALUE, the value is populated from
                               # current environment of hmake
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;env-files&lt;/code&gt;: list of files providing environment variables, see &lt;code&gt;--env-files&lt;/code&gt;
of &lt;code&gt;docker run&lt;/code&gt;;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;console&lt;/code&gt;: when &lt;code&gt;true&lt;/code&gt;, the current stdin/stdout/stderr is directly passed to
command which is able to fully control the current console, equivalent to
&lt;code&gt;docker run -it&lt;/code&gt;.
Default is false, equivalent to &lt;code&gt;docker run -a STDOUT -a STDERR&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;NOTE: When enabled, no output is captured or logged.&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;build&lt;/code&gt;: path to &lt;code&gt;Dockerfile&lt;/code&gt;, when specified, this target builds a docker
image first. &lt;code&gt;image&lt;/code&gt; property specifies the image name and tag.
The value can point to a &lt;code&gt;Dockerfile&lt;/code&gt; (e.g. &lt;code&gt;build: build/Dockerfile.arm&lt;/code&gt;)
which indicates the folder containing the file is the context folder.
And the value can also point to a folder which contains a &lt;code&gt;Dockerfile&lt;/code&gt;
(e.g. &lt;code&gt;build: build&lt;/code&gt;) which uses the folder as context folder and looks for
&lt;code&gt;Dockerfile&lt;/code&gt; there.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It&amp;rsquo;s strongly recommended to put &lt;code&gt;Dockerfile&lt;/code&gt; and any related files to
   &lt;code&gt;watches&lt;/code&gt; list;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;build-from&lt;/code&gt;: the path of context folder for &lt;code&gt;docker build&lt;/code&gt;.
Without this property, the path is derived from path of &lt;code&gt;Dockerfile&lt;/code&gt; specified
in &lt;code&gt;build&lt;/code&gt;. Please note, the path must be direct/indirect parent of the
&lt;code&gt;Dockerfile&lt;/code&gt; as required by &lt;code&gt;docker build&lt;/code&gt;;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;build-args&lt;/code&gt;: list of args, corresponding to &lt;code&gt;docker build&lt;/code&gt; option;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;image&lt;/code&gt;: with &lt;code&gt;build&lt;/code&gt; it&amp;rsquo;s the image name and tag to build,
without &lt;code&gt;build&lt;/code&gt;, it&amp;rsquo;s the image used to create the container;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;tags&lt;/code&gt;: a list of tags in addition to &lt;code&gt;image&lt;/code&gt; when do &lt;code&gt;docker build&lt;/code&gt;;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;commit&lt;/code&gt;: commit running container into new image. Support multiple tags.
Image tag will be &lt;code&gt;latest&lt;/code&gt;, if not self-defined in image name. E.g.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  target:
      image: new-image-name:newtag
      cmds:
          &amp;lt;Some commands&amp;gt;
      commit:
            - new-image-name:tag1
            - new-image-name:tag2
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cache&lt;/code&gt;: only used to specify &lt;code&gt;false&lt;/code&gt; which adds &lt;code&gt;--no-cache&lt;/code&gt; to &lt;code&gt;docker build&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;content-trust&lt;/code&gt;: only used to specify &lt;code&gt;false&lt;/code&gt; which adds
&lt;code&gt;--disable-content-trust&lt;/code&gt; to &lt;code&gt;docker build/run&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;src-volume&lt;/code&gt;: the full path inside container where project root is mapped to.
Default is &lt;code&gt;/src&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;expose-docker&lt;/code&gt;: when set &lt;code&gt;true&lt;/code&gt;, expose the host docker server connectivity
into container to allow docker client run from inside the container.
This is very useful when docker is required for build and avoid problematic
docker-in-docker;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;privileged&lt;/code&gt;: run container in privileged mode, default is &lt;code&gt;false&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;net&lt;/code&gt;: when specified, add &lt;code&gt;--net&lt;/code&gt; option to docker CLI.
When set to &lt;code&gt;host&lt;/code&gt;, also add &lt;code&gt;--uts=host&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;link&lt;/code&gt;: a list of strings of &lt;code&gt;container:hostname&lt;/code&gt; mapping to &lt;code&gt;--link&lt;/code&gt; option.
This is very useful when combined with &lt;code&gt;compose&lt;/code&gt; (docker-compose);&lt;/li&gt;
&lt;li&gt;&lt;code&gt;user&lt;/code&gt;: passed to &lt;code&gt;docker run --user...&lt;/code&gt;, by default, current &lt;code&gt;uid:gid&lt;/code&gt; are
passed (with &lt;em&gt;docker-machine&lt;/em&gt; the &lt;code&gt;uid:gid&lt;/code&gt; is queried from the virtual machine
running docker daemon).
It must be explicitly specified &lt;code&gt;root&lt;/code&gt; if the script is executed as root
inside container.
When a non-root user is explicitly specified, all group IDs are automatically
passed using &lt;code&gt;--group-add&lt;/code&gt;l;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;groups&lt;/code&gt;: explicitly specify group IDs to pass into container, instead of
passing all of them;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;volumes&lt;/code&gt;: a list of volume mappings passed to &lt;code&gt;-v&lt;/code&gt; option of &lt;code&gt;docker run&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compose&lt;/code&gt;: run &lt;code&gt;docker-compose&lt;/code&gt;, see below for details.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The following properties directly maps to &lt;code&gt;docker build/run&lt;/code&gt; options:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cap-add&lt;/code&gt;, &lt;code&gt;cap-drop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;devices&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hosts&lt;/code&gt;: mapped to &lt;code&gt;--add-host&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dns&lt;/code&gt;, &lt;code&gt;dns-opts&lt;/code&gt;, &lt;code&gt;dns-search&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;blkio-weight&lt;/code&gt;, &lt;code&gt;blkio-weight-devices&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;device-read-bps&lt;/code&gt;, &lt;code&gt;device-write-bps&lt;/code&gt;, &lt;code&gt;device-read-iops&lt;/code&gt;, &lt;code&gt;device-write-iops&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cpu-shares&lt;/code&gt;, &lt;code&gt;cpu-period&lt;/code&gt;, &lt;code&gt;cpu-quota&lt;/code&gt;, &lt;code&gt;cpuset-cpus&lt;/code&gt;, &lt;code&gt;cpuset-mems&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kernel-memory&lt;/code&gt;, &lt;code&gt;memory&lt;/code&gt;, &lt;code&gt;memory-swap&lt;/code&gt;, &lt;code&gt;memory-swappiness&lt;/code&gt;, &lt;code&gt;shm-size&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ulimit&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;labels&lt;/code&gt;, &lt;code&gt;label-files&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pull&lt;/code&gt;, &lt;code&gt;force-rm&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All above properties can also be specified in &lt;code&gt;settings&lt;/code&gt;/&lt;code&gt;local&lt;/code&gt; under
&lt;code&gt;docker&lt;/code&gt; section:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;settings:
    docker:
        property: value
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;volume-mapping&#34;&gt;Volume Mapping&lt;/h2&gt;

&lt;p&gt;By default the current project root is mapped into container at &lt;code&gt;src-volume&lt;/code&gt;,
default value is &lt;code&gt;/src&lt;/code&gt;.
As the script is a shell script, the executable &lt;code&gt;/bin/sh&lt;/code&gt; must be present in
the container.&lt;/p&gt;

&lt;p&gt;The host side path is translated with the following rule:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It&amp;rsquo;s relative path, it&amp;rsquo;s relative to working directory (property &lt;code&gt;workdir&lt;/code&gt;);&lt;/li&gt;
&lt;li&gt;It&amp;rsquo;s absolute path (including starting with &lt;code&gt;~/&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt; expands to home), it&amp;rsquo;s absolute on the host;&lt;/li&gt;
&lt;li&gt;It starts with &lt;code&gt;-/&lt;/code&gt;, it&amp;rsquo;s relative to project root.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;targets:
  volumes:
    - &#39;abc:/var/lib/abc&#39;  # host path is $HMAKE_PROJECT_DIR/$HMAKE_TARGET_DIR/abc
    - &#39;~/.ssh:/root/.ssh&#39; # host path is $HOME/.ssh
    - &#39;/var/lib:/var/lib&#39; # host path is /var/lib
    - &#39;-/src:/src&#39;        # host path is $HMAKE_PROJECT_DIR/src
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;NOTE&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;On Mac OS, only paths under &lt;code&gt;/Users&lt;/code&gt; can be mapped into the container.
All project trees must sit under &lt;code&gt;/Users&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;On Windows, only paths under &lt;code&gt;C:\Users&lt;/code&gt; can be mapped into the container.
All project trees must sit under &lt;code&gt;C:\Users&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;user&#34;&gt;User&lt;/h2&gt;

&lt;p&gt;By default &lt;em&gt;hmake&lt;/em&gt; uses current user (NOT root) to run inside container,
which make sure any file change has the same ownership as the environment outside.
If root is required, it can be explicitly specified &lt;code&gt;user: root&lt;/code&gt;,
however, all files created inside container will be owned by &lt;code&gt;root&lt;/code&gt; outside,
and you may eventually see some error messages like &lt;code&gt;permission denied&lt;/code&gt; when you
do something outside.&lt;/p&gt;

&lt;h2 id=&#34;docker-compose&#34;&gt;Docker Compose&lt;/h2&gt;

&lt;p&gt;The property &lt;code&gt;compose&lt;/code&gt; is used to run &lt;code&gt;docker-compose&lt;/code&gt; as a background task.
The value can be a single string pointing to a directory containing
&lt;code&gt;docker-compose.yml&lt;/code&gt; (&lt;code&gt;docker-compose.yaml&lt;/code&gt;) or a full path to a file with
alternative name instead of &lt;code&gt;docker-compose.yml&lt;/code&gt;,
or an object containing detailed properties:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;file&lt;/code&gt;: the path to a directory containing &lt;code&gt;docker-compose.yml&lt;/code&gt;, or to a file
with alternative name;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;project-name&lt;/code&gt;: override project name (&lt;code&gt;--project-name&lt;/code&gt;);&lt;/li&gt;
&lt;li&gt;&lt;code&gt;deps&lt;/code&gt;: when &lt;code&gt;false&lt;/code&gt;, add &lt;code&gt;--no-deps&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;recreate&lt;/code&gt;: when &lt;code&gt;false&lt;/code&gt;, add &lt;code&gt;--no-recreate&lt;/code&gt;, or &lt;code&gt;force&lt;/code&gt;, add &lt;code&gt;--force-recreate&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;build&lt;/code&gt;: when &lt;code&gt;true&lt;/code&gt;, add &lt;code&gt;--build&lt;/code&gt;, or &lt;code&gt;false&lt;/code&gt;, add &lt;code&gt;--no-build&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;remove-orphans&lt;/code&gt;: when &lt;code&gt;true&lt;/code&gt;, add &lt;code&gt;--remove-orphans&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;services&lt;/code&gt;: a list of strings as service names after &lt;code&gt;docker-compose up&lt;/code&gt; command line.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When &lt;code&gt;compose&lt;/code&gt; is present, the task is a background task.
&lt;code&gt;docker-compose up -d&lt;/code&gt; is used to launch containers in the background.
If &lt;code&gt;cmds&lt;/code&gt; or &lt;code&gt;build&lt;/code&gt; are also present in the same task, they are executed after
&lt;code&gt;docker-compose&lt;/code&gt; launched the containers.&lt;/p&gt;

&lt;p&gt;Other tasks can take dependency on a background task (e.g. with &lt;code&gt;compose&lt;/code&gt;), and
in this case, use &lt;code&gt;net&lt;/code&gt; and &lt;code&gt;link&lt;/code&gt; to connect task to containers launched by
&lt;code&gt;docker-compose&lt;/code&gt;. This is very useful to launch a testing environment and run
test code from tasks.&lt;/p&gt;

&lt;h2 id=&#34;known-issues&#34;&gt;Known Issues&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Docker machine backed by VirtualBox: Docker for Mac is recommended instead of VirtualBox

&lt;ul&gt;
&lt;li&gt;Unstable NAT service: the NAT service from VirtualBox will eventually disconnect;&lt;/li&gt;
&lt;li&gt;Hard link not supported: hard links can&amp;rsquo;t be created on mapped volumes;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Time drifting inside the VM: with Docker for Mac, the time may drift because there&amp;rsquo;s
no time synchronization at current stage;&lt;/li&gt;
&lt;li&gt;Memory exhaust: observed with Docker for Mac, restart Docker service solve the problem;&lt;/li&gt;
&lt;li&gt;Docker &lt;code&gt;--label&lt;/code&gt; bug: Docker &lt;em&gt;1.12&lt;/em&gt; has a bug parsing command line &lt;code&gt;--label&lt;/code&gt; which works
with Docker &lt;em&gt;1.11&lt;/em&gt;, putting labels inside &lt;code&gt;Dockerfile&lt;/code&gt; works fine.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;limits&#34;&gt;Limits&lt;/h2&gt;

&lt;p&gt;On Linux, &lt;em&gt;docker-machine&lt;/em&gt; is not supported, docker daemon must run on the same
host running &lt;em&gt;hmake&lt;/em&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://evo-cloud.github.com/hmake/docs/FAQ/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/docs/FAQ/</guid>
      <description>

&lt;h1 id=&#34;questions-and-best-practices&#34;&gt;Questions and Best Practices&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Q&lt;/strong&gt;: Why I can&amp;rsquo;t &lt;code&gt;git clone&lt;/code&gt; private repositories?&lt;br&gt;
&lt;strong&gt;A&lt;/strong&gt;: HyperMake runs the build inside containers which may not have the right
SSH keys or credentials. There&amp;rsquo;re two options:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Mapping &lt;code&gt;~/.ssh&lt;/code&gt; into the container using &lt;code&gt;volumes&lt;/code&gt; property:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;volumes:
  - &#39;~/.ssh:/src/.ssh:ro&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Mapping &lt;code&gt;~/.netrc&lt;/code&gt; into the container:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;first, create a file &lt;code&gt;~/.netrc&lt;/code&gt;. See the
&lt;a href=&#34;https://www.gnu.org/software/inetutils/manual/html_node/The-_002enetrc-file.html&#34;&gt;manual&lt;/a&gt;
for the format and content. E.g.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;machine github.com
protocol https
login username
password password
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then use &lt;code&gt;volumes&lt;/code&gt; property to map into the container.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;volumes:
  - &#39;~/.netrc:/src/.netrc:ro&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Q&lt;/strong&gt;: Can I build projects for Windows?&lt;br&gt;
&lt;strong&gt;A&lt;/strong&gt;: Depending on toolchain. HyperMake builds on Linux, for C/C++,
install &lt;a href=&#34;http://www.mingw.org&#34;&gt;mingw&lt;/a&gt; toolchain in the container and do
the cross complication.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Q&lt;/strong&gt;: Can I build projects for native Mac OS?&lt;br&gt;
&lt;strong&gt;A&lt;/strong&gt;: Depending. If it&amp;rsquo;s a project in Go, yes. If it depends on native Mac OS
libraries, it&amp;rsquo;s possible when cross compiling toolchain and libraries are
installed on Linux.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Q&lt;/strong&gt;: Why target is skipped but output file is not present?&lt;br&gt;
&lt;strong&gt;A&lt;/strong&gt;: Property &lt;code&gt;artifacts&lt;/code&gt; is not specified in the target. &lt;em&gt;HyperMake&lt;/em&gt; checks
both input and output files to determine if a target is up-to-date. Property
&lt;code&gt;watches&lt;/code&gt; lists the input files whose last modification time is checked, and
property &lt;code&gt;artifacts&lt;/code&gt; lists the output files whose presence is checked.
If &lt;code&gt;artifacts&lt;/code&gt; is not specified, &lt;em&gt;HyperMake&lt;/em&gt; assumes the target doesn&amp;rsquo;t generate
output files.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Q&lt;/strong&gt;: What&amp;rsquo;s the &lt;code&gt;artifacts&lt;/code&gt; if the target doesn&amp;rsquo;t output files?&lt;br&gt;
&lt;strong&gt;A&lt;/strong&gt;: No need to specify &lt;code&gt;artifacts&lt;/code&gt; if there&amp;rsquo;s no output file. Some targets
like docker build doesn&amp;rsquo;t output files, it will automatically check if the
image exists. To explicitly rebuild the target, use &lt;code&gt;-r TARGET&lt;/code&gt;, &lt;code&gt;-b&lt;/code&gt; or &lt;code&gt;-R&lt;/code&gt;
options.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Q&lt;/strong&gt;: I want to run some commands, which are specific to my local environment,
before certain targets. But I don&amp;rsquo;t want to put them in &lt;code&gt;HyperMake&lt;/code&gt; file.&lt;br&gt;
&lt;strong&gt;A&lt;/strong&gt;: You can create a &lt;code&gt;.hmakerc&lt;/code&gt; in project root, and exclude that file using
&lt;code&gt;.gitignore&lt;/code&gt;. The &lt;code&gt;settings&lt;/code&gt; in &lt;code&gt;.hmakerc&lt;/code&gt; will override those in &lt;code&gt;HyperMake&lt;/code&gt;
and use &lt;code&gt;before&lt;/code&gt; to inject your local targets into &lt;code&gt;HyperMake&lt;/code&gt;, e.g.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  ---
  format: hypermake.v0
  targets:
    pre-build:
      description: my local task before build
      before:
        - build
      cmds:
        - do something
  settings:
    property: my-value
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Q&lt;/strong&gt;: How to map a volume from a folder relative to project root?&lt;br&gt;
&lt;strong&gt;A&lt;/strong&gt;: In top-level &lt;code&gt;HyperMake&lt;/code&gt;, use relative path for source of the volume,
in &lt;code&gt;*.hmake&lt;/code&gt; files under sub-directories, prefix &lt;code&gt;-/&lt;/code&gt; to a relative path. E.g.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  targets:
    example:
      volumes:
        - &#39;-/run:/var/run&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Anyway, in &lt;code&gt;volumes&lt;/code&gt;, prefix &lt;code&gt;-/&lt;/code&gt; can always be used to indicate a path
  relative to project root. Please read &lt;a href=&#34;http://evo-cloud.github.com/hmake/hmake/docs/DockerDriver/&#34;&gt;Docker Driver&lt;/a&gt; for
  details.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Q&lt;/strong&gt;: Where can I find the output of my target after running &lt;code&gt;hmake&lt;/code&gt;?&lt;br&gt;
&lt;strong&gt;A&lt;/strong&gt;: &lt;code&gt;hmake&lt;/code&gt; creates a hidden folder &lt;code&gt;.hmake&lt;/code&gt; under project root. The output
of a target is saved in &lt;code&gt;.hmake/TARGET.log&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Q&lt;/strong&gt;: Does &lt;code&gt;hmake&lt;/code&gt; print logs?&lt;br&gt;
&lt;strong&gt;A&lt;/strong&gt;: Yes. &lt;code&gt;hmake&lt;/code&gt; writes its own debug logs in &lt;code&gt;.hmake/hmake.debug.log&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Q&lt;/strong&gt;: What&amp;rsquo;re the recommended entries in &lt;code&gt;.gitignore&lt;/code&gt;?&lt;br&gt;
&lt;strong&gt;A&lt;/strong&gt;: Put the following entries in &lt;code&gt;.gitignore&lt;/code&gt;:&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  .hmake
  .hmakerc
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://evo-cloud.github.com/hmake/docs/FileFormat/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/docs/FileFormat/</guid>
      <description>

&lt;h1 id=&#34;hypermake-file-format&#34;&gt;HyperMake File Format&lt;/h1&gt;

&lt;p&gt;File &lt;code&gt;HyperMake&lt;/code&gt; must be present in root directory of the project tree. Command
&lt;code&gt;hmake&lt;/code&gt; can be invoked in any sub-directories inside the project tree and it will
locate the root of project by looking up &lt;code&gt;HyperMake&lt;/code&gt;.
Additional files must be named as &lt;code&gt;*.hmake&lt;/code&gt; for being referenced in &lt;code&gt;includes&lt;/code&gt;
section.
All these files share the same format.&lt;/p&gt;

&lt;p&gt;In &lt;code&gt;HyperMake&lt;/code&gt; or &lt;code&gt;*.hmake&lt;/code&gt;, define the following things:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Format: the format presents the current file, should always be &lt;code&gt;hypermake.v0&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;Name and description: only defined in top-level &lt;code&gt;HyperMake&lt;/code&gt; file;&lt;/li&gt;
&lt;li&gt;Targets: the target to build, including dependencies and commands;&lt;/li&gt;
&lt;li&gt;Settings: the settings applies to &lt;em&gt;hmake&lt;/em&gt; and should be merged into a global view;&lt;/li&gt;
&lt;li&gt;Local Settings: the settings only apply to current &lt;code&gt;HyperMake&lt;/code&gt; or &lt;code&gt;.hmake&lt;/code&gt; file;&lt;/li&gt;
&lt;li&gt;Includes: include more &lt;code&gt;*.hmake&lt;/code&gt; files.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here&amp;rsquo;s the schema in example (this is from the &lt;code&gt;HyperMake&lt;/code&gt; file of &lt;code&gt;hmake&lt;/code&gt; project):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
format: hypermake.v0 # this indicates this is a HyperMake file

# project name and description
name: hmake
description: HyperMake builds your project without pre-requisites

# define targets
targets:
    builder:
        description: build the docker image including toolchain
        build: builder
        image: hmake-builder:latest
        watches:
            - builder

    vendor:
        description: pull all vendor packages
        after:
            - builder
        watches:
            - &#39;vendor/manifest&#39;
        cmds:
            - gvt restore

    # target hmake-linux- will be expanded to three target architectures
    hmake-linux-[arch:amd64,arm,arm64]:
        description: static linked hmake binary for linux-$[arch]
        after:
            - vendor
        watches:
            - &#39;**/**/*.go&#39;
            - build.sh
        cmds:
            - ./build.sh linux $[arch]
        artifacts:
            - bin/linux/$[arch]/hmake
            - bin/hmake-linux-$[arch].tar.gz
            - bin/hmake-linux-$[arch].tar.gz.sha256sum

    hmake-darwin-amd64:
        description: static linked hmake binary for Mac OS
        after:
            - vendor
        watches:
            - &#39;**/**/*.go&#39;
            - build.sh
        cmds:
            - ./build.sh darwin amd64
        artifacts:
            - bin/darwin/amd64/hmake
            - bin/hmake-darwin-amd64.tar.gz
            - bin/hmake-darwin-amd64.tar.gz.sha256sum

    hmake-windows-amd64:
        description: static linked hmake binary for Windows
        after:
            - vendor
        watches:
            - &#39;**/**/*.go&#39;
            - build.sh
        cmds:
            - ./build.sh windows amd64
        artifacts:
            - bin/windows/amd64/hmake.exe
            - bin/hmake-windows-amd64.zip
            - bin/hmake-windows-amd64.zip.sha256sum

    site:
        description: generate document site
        after:
            - builder
        watches:
            - site/gh-pages/config.toml
            - site/gh-pages/themes/**/**/*
            - site/gh-pages/static/**/**/*
            - README.md
            - docs/**/**/*
            - examples/*/README.md
            - build.sh
        cmds:
            - ./build.sh gensite

    checkfmt:
        description: check code format
        after:
            - builder
        always: true
        cmds:
            - ./build.sh checkfmt

    lint:
        description: check code using metalint
        after:
            - builder
        always: true
        cmds:
            - ./build.sh lint

    check:
        description: check source code
        after:
            - checkfmt
            - lint

    test:
        description: run tests
        after:
            - vendor
        always: true
        cmds:
            - ginkgo ./test

    cover:
        description: run tests with coverage
        after:
            - vendor
        always: true
        cmds:
            - &amp;gt;
                go test -coverprofile cover.out
                -coverpkg ./project
                ./test

    e2e:
        description: end-to-end tests
        after:
            - vendor
        expose-docker: true
        always: true
        cmds:
            - ginkgo ./test/e2e

    all:
        description: the default make target
        after:
            - hmake-linux-amd64
            - hmake-darwin-amd64
            - hmake-windows-amd64

# define some special targets which can be used as commands
commands:
    echo:
        description: simple echo command
        cmds:
            - &#39;echo $@&#39;

# settings shared across targets
settings:
    default-targets:
        - all
    docker:
        image: hmake-builder:latest
        src-volume: /go/src/github.com/evo-cloud/hmake

# same as settings, but only apply to targets in the same file
local:
    key: value

includes:
    - build/**/**/*.hmake
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;format&#34;&gt;Format&lt;/h2&gt;

&lt;p&gt;The format of this &lt;code&gt;YAML&lt;/code&gt; file is indicated by &lt;code&gt;format&lt;/code&gt; property which is
mandatory and the current acceptable value is &lt;code&gt;hypermake.v0&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;name-and-description&#34;&gt;Name and Description&lt;/h2&gt;

&lt;p&gt;These are optional properties, while it&amp;rsquo;s recommended &lt;code&gt;name&lt;/code&gt; should be provided
as project name.&lt;/p&gt;

&lt;h2 id=&#34;targets&#34;&gt;Targets&lt;/h2&gt;

&lt;p&gt;The property &lt;code&gt;targets&lt;/code&gt; defines a dictionary of named targets.
A target is a set of properties to define what to do (a script or a list of commands).
Usually, it defines&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The environment to execute the script/commands,
like docker image, workdir, and options for &lt;code&gt;docker run&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;The dependencies between targets, using &lt;code&gt;before&lt;/code&gt; and &lt;code&gt;after&lt;/code&gt; properties;&lt;/li&gt;
&lt;li&gt;Watch of files to decide whether the target should be rebuilt.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;commands&#34;&gt;Commands&lt;/h2&gt;

&lt;p&gt;Commands are special type of targets, when used, it must be the first non-option
argument in command line.
E.g. invoking &lt;code&gt;hmake&lt;/code&gt; like &lt;code&gt;hmake name arg1 arg2&lt;/code&gt;, if &lt;code&gt;name&lt;/code&gt; is defined
in &lt;code&gt;commands&lt;/code&gt;, the rest of arguments in the command line is passed as arguments
to command target &lt;code&gt;name&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Commands are targets, with a few restrictions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Commands should not be dependency of others. So &lt;code&gt;before&lt;/code&gt; is not allowed, and
other targets/commands should not &lt;code&gt;after&lt;/code&gt; a command;&lt;/li&gt;
&lt;li&gt;Command can only be used as the first non-option argument in &lt;em&gt;hmake&lt;/em&gt; command line
which turns on &lt;em&gt;command mode&lt;/em&gt;. In the case &lt;code&gt;hmake target1 cmd1&lt;/code&gt;, it refuses to
run because &lt;code&gt;cmd1&lt;/code&gt; is a command but not come first.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;common-properties-in-target&#34;&gt;Common Properties in Target&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;description&lt;/code&gt;: description of the target;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;before&lt;/code&gt;: a list of names of targets which can only execute after this target;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;after&lt;/code&gt;: a list of names of targets on which this targets depends;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;workdir&lt;/code&gt;: the current working directory for commands in the target,
relative to &lt;code&gt;.hmake&lt;/code&gt; file defining the target;
if it&amp;rsquo;s absolute (starting with &lt;code&gt;/&lt;/code&gt;), it&amp;rsquo;s relative to project root;
by default, it&amp;rsquo;s the current directory containing the &lt;code&gt;.hmake&lt;/code&gt; file.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;watches&lt;/code&gt;: a list of path/filenames (wildcard supported) whose mtime will be
checked to determine if the target is out-of-date, without specifying this
property, the target is automatically skipped if the last execution was successful
and all dependencies are skipped;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;always&lt;/code&gt;: always build the target regardless of last execution state and results
of all dependencies (the &lt;code&gt;.PHONY&lt;/code&gt; target in &lt;code&gt;make&lt;/code&gt;);&lt;/li&gt;
&lt;li&gt;&lt;code&gt;artifacts&lt;/code&gt;: a list of files/directory must be present after the execution of
the target (aka. the output of the target), in relative path to current &lt;code&gt;.hmake&lt;/code&gt;
file, or if it&amp;rsquo;s absolute path, it&amp;rsquo;s relative to project root.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Other properties are specific to execution driver which executes the target.
The currently supported execution driver is &lt;code&gt;docker&lt;/code&gt;, please read
&lt;a href=&#34;http://evo-cloud.github.com/hmake/hmake/docs/DockerDriver/&#34;&gt;Docker Driver&lt;/a&gt; for details.&lt;/p&gt;

&lt;h4 id=&#34;dependencies&#34;&gt;Dependencies&lt;/h4&gt;

&lt;p&gt;Dependencies are specified using:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;after&lt;/code&gt;: the target is executed when the depended tasks succeed or are skipped&lt;/li&gt;
&lt;li&gt;&lt;code&gt;before&lt;/code&gt;: the target must succeed or skip before the specified tasks get executed.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A &lt;em&gt;skipped&lt;/em&gt; target means there&amp;rsquo;s nothing to do with the target (no commands or
it&amp;rsquo;s still up-to-date). It can be an equivalent to &lt;em&gt;success&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;In most cases, &lt;code&gt;after&lt;/code&gt; is enough. &lt;code&gt;before&lt;/code&gt; is often used to inject dependencies.&lt;/p&gt;

&lt;h4 id=&#34;matching-targets-names-with-wildcards&#34;&gt;Matching targets names with wildcards&lt;/h4&gt;

&lt;p&gt;The places (&lt;code&gt;before&lt;/code&gt;, &lt;code&gt;after&lt;/code&gt;, &lt;code&gt;-r&lt;/code&gt;, &lt;code&gt;-S&lt;/code&gt;, command line targets, etc) requiring
target names accept wildcards:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Wildcards used in file names: &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;\&lt;/code&gt; and &lt;code&gt;[chars]&lt;/code&gt;, they are matched using &lt;code&gt;filepath.Match&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Regular Expression: the name starts and ends with &lt;code&gt;/&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;pre-defined-environment-variables&#34;&gt;Pre-defined Environment Variables&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HMAKE_PROJECT_NAME&lt;/code&gt;: the name of the project&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HMAKE_PROJECT_DIR&lt;/code&gt;: the directory containing &lt;code&gt;HyperMake&lt;/code&gt; (aka. project root)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HMAKE_PROJECT_FILE&lt;/code&gt;: the full path to &lt;code&gt;HyperMake&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HMAKE_WORK_DIR&lt;/code&gt;: &lt;code&gt;$HMAKE_PROJECT_DIR/.hmake&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HMAKE_LAUNCH_PATH&lt;/code&gt;: the relative path under &lt;code&gt;$HMAKE_PROJECT_DIR&lt;/code&gt; where &lt;code&gt;hmake&lt;/code&gt; launches&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HMAKE_REQUIRED_TARGETS&lt;/code&gt;: the names of targets explicitly required from command line, separate by space&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HMAKE_TARGET&lt;/code&gt;: the name of the target currently in execution&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HMAKE_TARGET_DIR&lt;/code&gt;: the relative path to directory containing the file which defines the target&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HMAKE_VERSION&lt;/code&gt;: version of &lt;em&gt;hmake&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HMAKE_OS&lt;/code&gt;: operating system&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HMAKE_ARCH&lt;/code&gt;: CPU architecture&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;target-expansions&#34;&gt;Target Expansions&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Target Expansion&lt;/em&gt; is useful when defining multiple targets with similar properties.
For example cross compiling for multiple targets, most of the properties are identical
only OS and CPU arch is different. In stead of duplicate the same blocks for each
target, writing one target with expansion syntax in target name, and &lt;em&gt;hmake&lt;/em&gt; will help
generate multiple targets using expansion information.&lt;/p&gt;

&lt;p&gt;In above example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;targets:
    hmake-linux-[arch:amd64,arm,arm64]:
        description: static linked hmake binary for linux-$[arch]
        after:
            - vendor
        watches:
            - &#39;**/**/*.go&#39;
            - build.sh
        cmds:
            - ./build.sh linux $[arch]
        artifacts:
            - bin/linux/$[arch]/hmake
            - bin/hmake-linux-$[arch].tar.gz
            - bin/hmake-linux-$[arch].tar.gz.sha256sum
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The target &lt;code&gt;hmake-linux-[arch:amd64,arm,arm64]&lt;/code&gt; will be expanded into three targets:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;hmake-linux-amd64&lt;/li&gt;
&lt;li&gt;hmake-linux-arm&lt;/li&gt;
&lt;li&gt;hmake-linux-arm64&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With &lt;code&gt;$[arch]&lt;/code&gt; substituted accordingly in each expanded targets.&lt;/p&gt;

&lt;p&gt;The syntax is simple: &lt;code&gt;[var-name:val1,val2,...]&lt;/code&gt; to define an expansion variable
with possible values, and in the properties, &lt;code&gt;$[var-name]&lt;/code&gt; will be substituted.
If &lt;code&gt;var-name&lt;/code&gt; is not defined in target name, &lt;code&gt;$[var-name]&lt;/code&gt; will NOT be substituted.
Specially, &lt;code&gt;$[$]&lt;/code&gt; substitutes to &lt;code&gt;$&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Multiple variables can be defined, example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;target-[os:linux,darwin]-[arch:386,amd64]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will expand to&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;target-linux-386&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;target-linux-amd64&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;target-darwin-386&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;target-darwin-amd64&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;include-files&#34;&gt;Include Files&lt;/h2&gt;

&lt;p&gt;In &lt;code&gt;includes&lt;/code&gt; section, specify files to be included.
The files included can provide more targets and also override settings.&lt;/p&gt;

&lt;p&gt;Any path used in &lt;code&gt;HyperMake&lt;/code&gt; or &lt;code&gt;*.hmake&lt;/code&gt; files are relative to current file.
When a target gets executed, the default working directory is where the file
defining the target exists.&lt;/p&gt;

&lt;h2 id=&#34;settings&#34;&gt;Settings&lt;/h2&gt;

&lt;p&gt;In &lt;code&gt;settings&lt;/code&gt; section, the hierarchical dictionary is used to provide
global settings. According to the order of &lt;code&gt;*.hmake&lt;/code&gt; files loaded, the file loaded
latter overrides the settings in the former loaded files.
In &lt;code&gt;local&lt;/code&gt; section, the settings are only applied to current file.
And the properties defined in target overrides everything.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the order &lt;em&gt;hmake&lt;/em&gt; looks a setting by name:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;From target&amp;rsquo;s properties;&lt;/li&gt;
&lt;li&gt;From &lt;code&gt;local&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;From &lt;code&gt;settings&lt;/code&gt; in the reversed order of files being loaded.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;pre-defined-setting-properties&#34;&gt;Pre-defined Setting Properties&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;default-targets&lt;/code&gt;: a list of targets to build when no targets are specified
in &lt;code&gt;hmake&lt;/code&gt; command;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker&lt;/code&gt;: a set of &lt;a href=&#34;http://evo-cloud.github.com/hmake/hmake/docs/DockerDriver/&#34;&gt;docker&lt;/a&gt; specific properties which defines
default values for targets.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;local-customization&#34;&gt;Local Customization&lt;/h2&gt;

&lt;p&gt;After loading &lt;code&gt;HyperMake&lt;/code&gt; and &lt;code&gt;*.hmake&lt;/code&gt; files, &lt;em&gt;hmake&lt;/em&gt; also looks up &lt;code&gt;.hmakerc&lt;/code&gt;
files from current directory up to root directory of the project and load them
in the order from root directory down to the current directory.
The &lt;code&gt;.hmakerc&lt;/code&gt; has the same format as &lt;code&gt;HyperMake&lt;/code&gt; and &lt;code&gt;*.hmake&lt;/code&gt; files and is
used to override settings and inject targets to satisfy the special needs of
local development environment.
&lt;code&gt;.hmakerc&lt;/code&gt; should be included in &lt;code&gt;.gitignore&lt;/code&gt; file.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://evo-cloud.github.com/hmake/docs/QuickStart/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/docs/QuickStart/</guid>
      <description>

&lt;h1 id=&#34;quick-start-guide&#34;&gt;Quick Start Guide&lt;/h1&gt;

&lt;p&gt;This is a guide to write a HyperMake file for your project for the first time.&lt;/p&gt;

&lt;h2 id=&#34;before-start&#34;&gt;Before Start&lt;/h2&gt;

&lt;p&gt;You need a project, of course. Let&amp;rsquo;s make a simple &lt;em&gt;Hello World&lt;/em&gt; C++ project,
and see how HyperMake can help.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the project directory layout:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ProjectRoot
  |
  +--inc/
  +--src/
      +--hello.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In &lt;code&gt;hello.cpp&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;

int main(int argc, char *argv[]) {
    std::cout &amp;lt;&amp;lt; &amp;quot;Hello World!&amp;quot; &amp;lt;&amp;lt; std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To build it, use &lt;code&gt;g++ -o hello src/hello.cpp&lt;/code&gt;. You will need toolchain installed.
Now, let&amp;rsquo;s create a &lt;code&gt;HyperMake&lt;/code&gt; to simplify the build.&lt;/p&gt;

&lt;h2 id=&#34;create-hypermake&#34;&gt;Create &lt;code&gt;HyperMake&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;HyperMake&lt;/code&gt; can be composed in two ways:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Wrapper mode: which wraps existing build tools, like GNU make&lt;/li&gt;
&lt;li&gt;Full mode: the native HyperMake format with all features.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For &lt;em&gt;Wrapper mode&lt;/em&gt;, read details in &lt;a href=&#34;http://evo-cloud.github.com/hmake/hmake/docs/WrapperMode/&#34;&gt;Wrapper Mode&lt;/a&gt;.
In this guide, we will use &lt;em&gt;Full mode&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Create a file called &lt;code&gt;HyperMake&lt;/code&gt; under &lt;code&gt;ProjectRoot&lt;/code&gt;.
It&amp;rsquo;s a &lt;em&gt;YAML&lt;/em&gt; file, so let&amp;rsquo;s start with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
format: hypermake.v0
name: hello
description: The Hello World Project
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first line &lt;code&gt;---&lt;/code&gt; is optional but recommended, as YAML parser will treat it
as the beginning of a new document.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;format&lt;/code&gt; is required and must be assigned with &lt;code&gt;hypermake.v0&lt;/code&gt;.
&lt;em&gt;hmake&lt;/em&gt; only parses YAML files with &lt;code&gt;format: hypermake.v0&lt;/code&gt;.
&lt;code&gt;name&lt;/code&gt; specifies the project name, which is required.
&lt;code&gt;description&lt;/code&gt; gives more information about the project. It&amp;rsquo;s optional.&lt;/p&gt;

&lt;h2 id=&#34;adding-targets&#34;&gt;Adding targets&lt;/h2&gt;

&lt;p&gt;The most important part is the section defining targets:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
format: hypermake.v0
name: hello
description: The Hello World Project

targets:
  build:
    description: build hello binary
    image: &#39;gcc:4.9&#39;
    cmds:
      - g++ -o hello src/hello.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We defined one target above: &lt;code&gt;build&lt;/code&gt;. It has three properties:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;description&lt;/code&gt;: a brief intro about what the target does;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;image&lt;/code&gt;: the docker image used to create the container and run commands;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cmds&lt;/code&gt;: a list of commands to execute inside the container.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now, we can use &lt;code&gt;hmake build&lt;/code&gt; to build the project, and type&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to show &lt;code&gt;Hello World&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Under the hood, &lt;code&gt;hmake&lt;/code&gt; creates a container temporarily, and maps current project
root to &lt;code&gt;/src&lt;/code&gt; inside container and run the commands inside the container.&lt;/p&gt;

&lt;p&gt;Are you feeling boring type &lt;code&gt;hmake build&lt;/code&gt; every time? Why not just &lt;code&gt;hmake&lt;/code&gt;?
Let&amp;rsquo;s move on with default targets.&lt;/p&gt;

&lt;h2 id=&#34;settings&#34;&gt;Settings&lt;/h2&gt;

&lt;p&gt;The default targets can be specified inside &lt;code&gt;settings&lt;/code&gt; section:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
format: hypermake.v0
name: hello
description: The Hello World Project

targets:
  build:
    description: build hello binary
    image: &#39;gcc:4.9&#39;
    cmds:
      - g++ -o hello src/hello.cpp

settings:
  default-targets:
    - build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With &lt;code&gt;default-targets&lt;/code&gt; specified in &lt;code&gt;settings&lt;/code&gt;, we can type &lt;code&gt;hmake&lt;/code&gt; without
arguments and it will run targets defined in &lt;code&gt;default-targets&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;settings&lt;/code&gt; section defines properties which are common to all targets.
For example, we can define common properties for &lt;code&gt;docker&lt;/code&gt;. Let&amp;rsquo;s move &lt;code&gt;image&lt;/code&gt;
property to settings:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
format: hypermake.v0
name: hello
description: The Hello World Project

targets:
  build:
    description: build hello binary
    cmds:
      - g++ -o hello src/hello.cpp

settings:
  default-targets:
    - build
  docker:
    image: &#39;gcc:4.9&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we moved &lt;code&gt;image&lt;/code&gt; to &lt;code&gt;settings/docker&lt;/code&gt;, we can remove &lt;code&gt;images&lt;/code&gt; from target
&lt;code&gt;build&lt;/code&gt;. And all targets will have &lt;code&gt;image: &#39;gcc:4.9&#39;&lt;/code&gt; by default.&lt;/p&gt;

&lt;h2 id=&#34;watches-and-artifacts&#34;&gt;Watches and Artifacts&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s do some tricks here: &lt;code&gt;touch src/hello.cpp&lt;/code&gt; or modify the file, and then
type &lt;code&gt;hmake&lt;/code&gt;. You will see the &lt;code&gt;build&lt;/code&gt; target is skipped:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HyperMake v1.1.0 https://github.com/evo-cloud/hmake

=&amp;gt; build 21:56:42.277
:] build
╔══════╤═══════╤════════╤════════════╤════════════╤═════╗
║Target│Result │Duration│Start       │Finish      │Error║
╠══════╪═══════╪════════╪════════════╪════════════╪═════╣
║build │Skipped│        │21:56:42.277│21:56:42.277│     ║
╚══════╧═══════╧════════╧════════════╧════════════╧═════╝
OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is definitely not what we want. The problem is &lt;em&gt;hmake&lt;/em&gt; doesn&amp;rsquo;t know which
files are input and which are output. Let&amp;rsquo;s tell &lt;em&gt;hmake&lt;/em&gt; by adding &lt;code&gt;watches&lt;/code&gt; and
&lt;code&gt;artifacts&lt;/code&gt; to target &lt;code&gt;build&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;targets:
  build:
    description: build hello binary
    watches:
      - inc
      - src
    cmds:
      - g++ -o hello src/hello.cpp
    artifacts:
      - hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The items in &lt;code&gt;watches&lt;/code&gt; can be a path to a directory or a file, or with wildcards
matching a list of files/directories. If the item is a directory, all sub-directories
and files are watched recursively.
&lt;code&gt;artifacts&lt;/code&gt; lists the output files. &lt;em&gt;hmake&lt;/em&gt; rebuilds the target if any of the
artifacts is missing. Wildcard is not allowed here, and directory is not matched
recursively.&lt;/p&gt;

&lt;p&gt;Some targets doesn&amp;rsquo;t require input files or generate output files. In this case
command line options can be used to explicitly rebuild the target: &lt;code&gt;-R&lt;/code&gt;, &lt;code&gt;-r&lt;/code&gt;, or
&lt;code&gt;-b&lt;/code&gt;. See &lt;a href=&#34;http://evo-cloud.github.com/hmake/hmake/docs/CommandLine/&#34;&gt;Command Line&lt;/a&gt; for details.&lt;/p&gt;

&lt;h2 id=&#34;dependencies&#34;&gt;Dependencies&lt;/h2&gt;

&lt;p&gt;As the project is so simple that we can use an existing docker image &lt;code&gt;gcc:4.9&lt;/code&gt; which
contains toolchain we need.
However in most cases, the existing docker images are not always good enough, and
we want to install extra bits to build the project.
Then we need to build our own toolchain image.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s use &lt;code&gt;cmake&lt;/code&gt; to build our project, by adding &lt;code&gt;CMakeList.txt&lt;/code&gt; under project root:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cmake_minimum_required(VERSION 2.8.0)
project(hello CXX)
include_directories(&amp;quot;inc&amp;quot;)
add_executable(hello src/hello.cpp)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we will need &lt;code&gt;cmake&lt;/code&gt; in toolchain image, let&amp;rsquo;s build one based on &lt;code&gt;gcc:4.9&lt;/code&gt;.
Create a folder &lt;code&gt;toolchain&lt;/code&gt; under project root and put a &lt;code&gt;Dockerfile&lt;/code&gt; inside it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM gcc:4.9
RUN apt-get update &amp;amp;&amp;amp; apt-get install -y cmake &amp;amp;&amp;amp; apt-get clean
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And update &lt;code&gt;HyperMake&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
format: hypermake.v0
name: hello
description: The Hello World Project

targets:
  toolchain:
    description: build our own toolchain image
    watches:
      - toolchain
    build: toolchain

  build:
    description: build hello binary
    after:
      - toolchain
    watches:
      - inc
      - src
    cmds:
      - rm -fr rel &amp;amp;&amp;amp; mkdir -p rel
      - cd rel &amp;amp;&amp;amp; cmake .. &amp;amp;&amp;amp; make
    artifacts:
      - rel/hello

settings:
  default-targets:
    - build
  docker:
    image: &#39;cmake-gcc:4.9&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Target &lt;code&gt;toolchain&lt;/code&gt; is added, with property &lt;code&gt;build&lt;/code&gt;, &lt;em&gt;hmake&lt;/em&gt; knows to build a
docker image, using &lt;code&gt;toolchain/Dockerfile&lt;/code&gt;. And as &lt;code&gt;image: cmake-gcc:4.9&lt;/code&gt; is specified
in &lt;code&gt;settings&lt;/code&gt;, the built image will be &lt;code&gt;cmake-gcc:4.9&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In target &lt;code&gt;build&lt;/code&gt;, &lt;code&gt;after&lt;/code&gt; specifies &lt;code&gt;toolchain&lt;/code&gt; must succeed before &lt;code&gt;build&lt;/code&gt; is able
to run. Because &lt;code&gt;build&lt;/code&gt; will use the image &lt;code&gt;cmake-gcc:4.9&lt;/code&gt; generated by &lt;code&gt;toolchain&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now, type &lt;code&gt;hmake&lt;/code&gt; and it will first run &lt;code&gt;toolchain&lt;/code&gt; to build &lt;code&gt;cmake-gcc:4.9&lt;/code&gt; and
the run &lt;code&gt;build&lt;/code&gt; to call &lt;code&gt;cmake&lt;/code&gt; to build the binary.&lt;/p&gt;

&lt;h2 id=&#34;more&#34;&gt;More&lt;/h2&gt;

&lt;p&gt;The above covers the basic features of &lt;em&gt;HyperMake&lt;/em&gt;.
There are a lot more useful features.
Please read documents listed in &lt;a href=&#34;http://evo-cloud.github.com/hmake/hmake/README/&#34;&gt;README&lt;/a&gt; for more details, and take
a look at &lt;code&gt;examples&lt;/code&gt; for real samples.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://evo-cloud.github.com/hmake/docs/UseCases/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/docs/UseCases/</guid>
      <description>

&lt;h1 id=&#34;how-hypermake-helps-make-life-easier&#34;&gt;How HyperMake Helps Make Life Easier&lt;/h1&gt;

&lt;h2 id=&#34;on-board-new-team-member&#34;&gt;On-board New Team Member&lt;/h2&gt;

&lt;p&gt;Most software projects have complicated requirements to setup a development
environment. There are always a list of software to install, including a
specific version of toolchain, specific versions of libraries, etc.&lt;/p&gt;

&lt;p&gt;The new member on-board experience often suffers, and usually takes days up to
weeks.&lt;/p&gt;

&lt;p&gt;With &lt;em&gt;HyperMake&lt;/em&gt;, the on-board experience is simplest. The new member only need
to install &lt;a href=&#34;https://www.docker.com&#34;&gt;docker&lt;/a&gt; and &lt;code&gt;hmake&lt;/code&gt; executable.
Then the project will be built smoothly.&lt;/p&gt;

&lt;h2 id=&#34;deliver-an-open-source-project&#34;&gt;Deliver an Open Source Project&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Compiling from source&lt;/em&gt; is challenging work for most of people.
However, it&amp;rsquo;s unavoidable if new features are required and a pre-built package is
not available.
If the project is built using &lt;em&gt;HyperMake&lt;/em&gt;, it makes &lt;em&gt;compiling from source&lt;/em&gt; the
simplest thing on the world.&lt;/p&gt;

&lt;h2 id=&#34;build-test-product-consistently&#34;&gt;Build/Test Product Consistently&lt;/h2&gt;

&lt;p&gt;People often complain &lt;em&gt;environment issue&lt;/em&gt; when building/testing a software product.
Because the &lt;em&gt;environments&lt;/em&gt; (toolchain, libraries) can&amp;rsquo;t always be identical from
developer to developer. Things work fine in one environment will likely be
broken in another environment.
With help of &lt;em&gt;HyperMake&lt;/em&gt;, the product is always built/tested in a clean and consistent
way because the same docker image is used across all different environments.&lt;/p&gt;

&lt;h2 id=&#34;platform-independent-development&#34;&gt;Platform-independent Development&lt;/h2&gt;

&lt;p&gt;With &lt;em&gt;HyperMake&lt;/em&gt;, it no longer requires developers work on specific platform.
As long as the project can be built on Linux, the developer is free to choose working
on Linux/Mac OS/Windows.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://evo-cloud.github.com/hmake/docs/WrapperMode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/docs/WrapperMode/</guid>
      <description>

&lt;h1 id=&#34;hypermake-wrapper-mode&#34;&gt;HyperMake Wrapper Mode&lt;/h1&gt;

&lt;p&gt;The &lt;em&gt;Wrapper Mode&lt;/em&gt; is the most quick and simplest way to adopt &lt;em&gt;HyperMake&lt;/em&gt;
with existing projects which already has full build system, like GNU make.&lt;/p&gt;

&lt;h2 id=&#34;one-line-just-works&#34;&gt;One line, just works!&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;echo &#39;#hmake-wrapper dockcross/linux-armv7&#39; &amp;gt;HyperMake
hmake
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The magic word &lt;code&gt;#hmake-wrapper&lt;/code&gt; in the beginning of &lt;code&gt;HyperMake&lt;/code&gt; file indicates
the &lt;em&gt;Wrapper Mode&lt;/em&gt; of &lt;em&gt;HyperMake&lt;/em&gt;.
It runs &lt;code&gt;make&lt;/code&gt; inside container created from image &lt;code&gt;dockcross/linux-armv7&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;wrapper-mode-file-format&#34;&gt;Wrapper Mode File Format&lt;/h2&gt;

&lt;h3 id=&#34;first-line&#34;&gt;First Line&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#hmake-wrapper IMAGE Dockerfile-FOR-BUILD BUILD-ARGS
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;IMAGE&lt;/code&gt;: required, the docker image used to create the container;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Dockerfile-FOR-BUILD&lt;/code&gt;: optional, relative path to a folder containing
&lt;code&gt;Dockerfile&lt;/code&gt;,  or full path to file if it&amp;rsquo;s not named &lt;code&gt;Dockerfile&lt;/code&gt;.
When this is present, &lt;code&gt;IMAGE&lt;/code&gt; is built locally from the &lt;code&gt;Dockerfile&lt;/code&gt; before
run the wrapped build tool;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BUILD-ARGS&lt;/code&gt;: optional, space separated &lt;code&gt;KEY=VALUE&lt;/code&gt; directly passed to
&lt;code&gt;--build-args&lt;/code&gt; option of &lt;code&gt;docker build&lt;/code&gt; command.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;E.g.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#hmake-wrapper mytoolchain-armhf toolchain/Dockerfile.armhf ARCH=armhf
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;second-line&#34;&gt;Second Line&lt;/h3&gt;

&lt;p&gt;If &lt;code&gt;HyperMake&lt;/code&gt; only contains the first line, the wrapped build tool is assumed
to be &lt;code&gt;make&lt;/code&gt;. The following command &lt;code&gt;hmake&lt;/code&gt; will run &lt;code&gt;make&lt;/code&gt; inside the container
passing all command line arguments to &lt;code&gt;make&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If there are additional lines in the file, the rest of the lines are written to
a script file, and &lt;code&gt;hmake&lt;/code&gt; run this script file inside the container, passing
all command line arguments to this script file.&lt;/p&gt;

&lt;p&gt;By default, the script file is generated with &lt;code&gt;#!/bin/sh&lt;/code&gt; as first line, and then
filled with the rest lines in &lt;code&gt;HyperMake&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;E.g.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#hmake-wrapper mytoolchain-armhf toolchain/Dockerfile.armhf ARCH=armhf
set -ex
exec ./build.sh &amp;quot;$@&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this, &lt;code&gt;hmake&lt;/code&gt; will invoke a script inside container like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/sh
set -ex
exec ./build.sh &amp;quot;$@&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, we may not always use shell scripts.
It&amp;rsquo;s possible to write in any scripting language when the second line is explicitly
specified:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#hmake-wrapper mytoolchain-armhf toolchain/Dockerfile.armhf ARCH=armhf
#!/usr/bin/env python
import sys
print(sys.argv)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;easy-huh&#34;&gt;Easy! Huh?&lt;/h2&gt;

&lt;p&gt;To utilize full features of &lt;em&gt;HyperMake&lt;/em&gt;, the native &lt;a href=&#34;http://evo-cloud.github.com/hmake/hmake/docs/FileFormat/&#34;&gt;File Format&lt;/a&gt;
is recommended.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://evo-cloud.github.com/hmake/examples/arm-hello/README/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/examples/arm-hello/README/</guid>
      <description>

&lt;h1 id=&#34;hello-world-built-for-arm&#34;&gt;Hello World built for ARM&lt;/h1&gt;

&lt;p&gt;This example demonstrates the use of &lt;em&gt;HyperMake Wrapper Mode&lt;/em&gt; to quickly build
a project which requires a special toolchain. It just works!&lt;/p&gt;

&lt;h2 id=&#34;hello-world&#34;&gt;Hello World&lt;/h2&gt;

&lt;p&gt;The project is a very simple &lt;em&gt;Hello World&lt;/em&gt; C program, however, we want to build
it for ARM processors.
The cross compiler &lt;code&gt;arm-linux-gnueabihf-gcc&lt;/code&gt; is required, but not installed on
the host.&lt;/p&gt;

&lt;p&gt;Installing a cross compiler is not easy, though we can use &lt;code&gt;apt-get ...&lt;/code&gt;, it won&amp;rsquo;t
make host system clean.&lt;/p&gt;

&lt;p&gt;By using docker image &lt;code&gt;dockcross/linux-armv7&lt;/code&gt; which always contains the toolchain,
the wrapper &lt;code&gt;HyperMake&lt;/code&gt; file simply makes it built!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://evo-cloud.github.com/hmake/examples/linux/README/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/examples/linux/README/</guid>
      <description>

&lt;h1 id=&#34;example-build-linux-kernel&#34;&gt;Example - Build Linux Kernel&lt;/h1&gt;

&lt;p&gt;This example builds linux kernel for multiple platforms using HyperMake.&lt;/p&gt;

&lt;h2 id=&#34;get-started&#34;&gt;Get Started&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;hmake -C examples/linux -sv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And collect outputs from &lt;code&gt;build/out/PLATFORM/arch/ARCH/boot&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;structure&#34;&gt;Structure&lt;/h2&gt;

&lt;p&gt;On top directory, &lt;code&gt;HyperMake&lt;/code&gt; defines the project and top-level targets.
And some scripts implements the build related logic which can be easily called
in other hmake targets.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;builders&lt;/code&gt; directory contains &lt;code&gt;*.hmake&lt;/code&gt; files which define targets building
docker images with required toolchain.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;targets&lt;/code&gt; directory contains sub-directories for different platforms.
Each sub-directory contains a &lt;code&gt;config&lt;/code&gt; file which is used as kernel config file,
and a &lt;code&gt;.hmake&lt;/code&gt; file defining targets to build/clean the kernel.&lt;/p&gt;

&lt;p&gt;When build starts, an intermediate directory &lt;code&gt;build&lt;/code&gt; is created.
&lt;code&gt;build/src&lt;/code&gt; contains the Linux kernel source, and &lt;code&gt;build/out/PLATFORM&lt;/code&gt; is created
for output of specific platform.
By building the kernel in separated platform directories, it&amp;rsquo;s possible to build
kernel for multiple platform in parallel.&lt;/p&gt;

&lt;h2 id=&#34;add-a-new-platform&#34;&gt;Add a new platform&lt;/h2&gt;

&lt;p&gt;It&amp;rsquo;s very easy to add a new platform:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Create folder &lt;code&gt;targets/PLATFORM&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Generate/Copy &lt;code&gt;config&lt;/code&gt; (kernel config) to &lt;code&gt;targets/PLATFORM&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Create &lt;code&gt;targets/PLATFORM/target.hmake&lt;/code&gt; containing hmake targets of:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;target-PLATFORM&lt;/code&gt;: it builds the kernel&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clean-PLATFORM&lt;/code&gt;: it removes &lt;code&gt;build/out/PLATFORM&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The recommended naming convention for &lt;code&gt;PLATFORM&lt;/code&gt; is &lt;code&gt;ARCH-BOARD&lt;/code&gt;,
e.g. &lt;code&gt;arm-vexpress&lt;/code&gt; is to build kernel for VExpress board with ARM CPU.&lt;/p&gt;

&lt;h2 id=&#34;other-targets&#34;&gt;Other targets&lt;/h2&gt;

&lt;p&gt;In &lt;code&gt;HyperMake&lt;/code&gt;, additional targets are defined to help build the kernel:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nconfig&lt;/code&gt;/&lt;code&gt;menuconfig&lt;/code&gt;: these maps to &lt;code&gt;make nconfig/menuconfig&lt;/code&gt;. It helps you
to edit the kernel config file. The config file is saved in &lt;code&gt;build/out/config/.config&lt;/code&gt;.
After finishing the config, you can copy this file to your platform folder.
These targets also demonstrate the use of &lt;code&gt;console&lt;/code&gt; property in hmake to allow
interactive targets.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;build-with-a-different-kernel-version&#34;&gt;Build with a different kernel version&lt;/h2&gt;

&lt;p&gt;The kernel version is hard-coded in &lt;code&gt;fetch.sh&lt;/code&gt;.
To use a different kernel version, simply update &lt;code&gt;fetch.sh&lt;/code&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>