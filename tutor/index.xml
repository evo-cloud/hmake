<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorials on HyperMake</title>
    <link>http://evo-cloud.github.com/hmake/tutor/</link>
    <description>Recent content in Tutorials on HyperMake</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="http://evo-cloud.github.com/hmake/tutor/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>A HyperMake Project</title>
      <link>http://evo-cloud.github.com/hmake/tutor/project/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/tutor/project/</guid>
      <description>Project Layout A HyperMake project requires one HyperMake file in root directory of the project (The file name can be overridden using --file|-f, see Command Line for details). The command hmake can be invoked in any sub-directory of the project and it will look up HyperMake to determine the root of project.
Similar to a Makefile, HyperMake defines targets with dependencies (see File Format). To better organize the targets, it&amp;rsquo;s possible to break targets into multiple files.</description>
    </item>
    
    <item>
      <title>Target Execution</title>
      <link>http://evo-cloud.github.com/hmake/tutor/targetexec/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/tutor/targetexec/</guid>
      <description>For full specification of all properties, please refer to
 File Format Docker Driver  How Target Executes A target always executes inside Docker container.
--- format: hypermake.v0 name: hello description: The Hello World Project targets: build: description: build hello binary image: &#39;gcc:4.9&#39; cmds: - g++ -o hello src/hello.cpp - strip hello  In the above example, a container is created using image gcc:4.9 as specified by property image. And lines in cmds are merged into a shell script .</description>
    </item>
    
    <item>
      <title>Build Docker Image</title>
      <link>http://evo-cloud.github.com/hmake/tutor/buildimage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/tutor/buildimage/</guid>
      <description>It&amp;rsquo;s simple and straight-forward to build Docker images using hmake.
Use Docker build --- format: hypermake.v0 name: build-sample targets: build-image: description: build docker image build: dir-contains-Dockerfile image: &#39;my-image:tag&#39; tags: - &#39;my-image1:tag1&#39; - &#39;my-image2:tag2&#39;  Specify property build to run docker build for the target. The value can be a path to a directory containing Dockerfile, or path including filename. If filename is included, it&amp;rsquo;s not necessary to be Dockerfile, hmake will take care of the right command line arguments to docker build.</description>
    </item>
    
    <item>
      <title>Push Docker Image</title>
      <link>http://evo-cloud.github.com/hmake/tutor/pushimage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/tutor/pushimage/</guid>
      <description>hmake provides built-in support to push docker image to a remote registry.
--- format: hypermake.v0 name: push-sample targets: build-image: description: build docker image build: Dockerfile image: &#39;myimage:tag&#39; tags: - &#39;registry:5000/namespace/myimage:tag&#39; - &#39;registry1/namespace/myimage:tag&#39; push-image: description: push docker images after: - build-image push: - &#39;registry:5000/namespace/myimage:tag&#39; - &#39;registry1/namespace/myimage:tag&#39;  The property push specifies which images to push. hmake calls docker push locally to push the images, so make sure the credentials are stored using docker login if the registry requires authentication.</description>
    </item>
    
    <item>
      <title>Docker Compose</title>
      <link>http://evo-cloud.github.com/hmake/tutor/compose/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/tutor/compose/</guid>
      <description>hmake supports docker-compose out-of-box, using property compose.
--- format: hypermake.v0 name: compose-sample targets: build: description: build from source code cmds: - ./build.sh artifacts: - out/service/Dockerfile - out/service/service.bin - out/service-compose/docker-compose.yml pack: description: pack as docker image after: - build build: out/service image: &#39;myservice:latest&#39; start: description: start built service in background after: - pack compose: out/service-compose test: description: test against service after: - start link: - &#39;service:service&#39; cmds: - ./test.sh  Please refer to Background Target, Docker Driver for details.</description>
    </item>
    
    <item>
      <title>Exec(Debug) Mode</title>
      <link>http://evo-cloud.github.com/hmake/tutor/execmode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/tutor/execmode/</guid>
      <description>exec mode allows execution of arbitrary command inside the container under the context of the specified target. It&amp;rsquo;s very useful to debug the environment.
Overview --- format: hypermake.v0 targets: build: description: build the source code cmds: - ./build.sh env: - FLAG=1 test: description: run test cmds: - ./test.sh settings: exec-target: build docker: image: &#39;ubuntu:latest&#39;  Sometimes, developers need to get into the execution environment of a target to find out what goes wrong.</description>
    </item>
    
    <item>
      <title>Command Mode</title>
      <link>http://evo-cloud.github.com/hmake/tutor/commandmode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/tutor/commandmode/</guid>
      <description>Overview Similar to make, the command line arguments are interpreted as targets name for hmake. In addition to that, hmake introduces a special type of targets - commands. When these targets are invoked, the command line arguments will be passed through to the target as arguments.
See File Format for details.
--- format: hypermake.v0 targets: build: description: build the source code cmds: - ./build.sh commands: pack-for: description: pack for specified target after: - build cmds: - &#39;.</description>
    </item>
    
    <item>
      <title>Map Credentials</title>
      <link>http://evo-cloud.github.com/hmake/tutor/mapcreds/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/tutor/mapcreds/</guid>
      <description>Problem Many CLI tools like docker, aws-cli, gcloud etc stores credentials in user&amp;rsquo;s home directory. When build directly from the host, there&amp;rsquo;s no problem accessing these services. However, using hmake, build runs inside container which doesn&amp;rsquo;t have the right credentials, and will fail.
Solution Here&amp;rsquo;s a commonly used practice to map credentials from local home directory.
--- format: hypermake.v0 name: map-credentials targets: build: description: build source code cmds: - .</description>
    </item>
    
    <item>
      <title>Target Expansion</title>
      <link>http://evo-cloud.github.com/hmake/tutor/targetexp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/tutor/targetexp/</guid>
      <description>It&amp;rsquo;s quite common targets are defined similarly with very small difference. For example, a build target which builds for different CPU architectures, the only difference can be the name passing to the build script.
--- format: hypermake.v0 name: expand-sample targets: hmake-linux-amd64: description: static linked hmake binary for linux-amd64 after: - vendor watches: - &#39;**/**/*.go&#39; - build.sh cmds: - ./build.sh linux amd64 artifacts: - bin/linux/amd64/hmake - bin/hmake-linux-amd64.tar.gz - bin/hmake-linux-amd64.tar.gz.sha256sum hmake-linux-arm: description: static linked hmake binary for linux-arm after: - vendor watches: - &#39;**/**/*.</description>
    </item>
    
    <item>
      <title>Wrapper Mode</title>
      <link>http://evo-cloud.github.com/hmake/tutor/wrappermode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/tutor/wrappermode/</guid>
      <description>I have a project using Makefile; I don&amp;rsquo;t want to learn HyperMake. But building in container is very appealing to me.
hmake provides a special wrapper mode for legacy projects.
A Simple and Quick Start echo &#39;#hmake-wrapper gcc:4.9&#39; &amp;gt;HyperMake  Now hmake becomes a wrapper of make
hmake target1 target2  is equivalent to
make target1 target2  but inside a container created from gcc:4.9.
Specification In wrapper mode, HyperMake may contain one or more lines.</description>
    </item>
    
    <item>
      <title>FAQ</title>
      <link>http://evo-cloud.github.com/hmake/tutor/faq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://evo-cloud.github.com/hmake/tutor/faq/</guid>
      <description>Q: Why I can&amp;rsquo;t git clone private repositories?
A: HyperMake runs the build inside containers which may not have the right SSH keys or credentials. There&amp;rsquo;re two options:
 Mapping ~/.ssh into the container using volumes property:  volumes: - &#39;~/.ssh:/src/.ssh:ro&#39;   Mapping ~/.netrc into the container:  first, create a file ~/.netrc. See the manual for the format and content. E.g.
machine github.com protocol https login username password password  Then use volumes property to map into the container.</description>
    </item>
    
  </channel>
</rss>