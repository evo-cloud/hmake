[
    {
        "uri": "/content/intro/_index",
        "title": "Introduction",
        "content": "Introduction\n\nHyperMake is a make-like build tool builds projects inside Docker Containers\nwhich have the complete toolchain packaged,\nthus no pre-requisites need to be installed on the host.\n\n What does this mean?\n\nThe project can always be built consistently on any hosts (Windows/Mac/Linux)\n  running Docker;\nAnyone is able to build the project instantly and successfully,\n  no worry about build environment,\n  required software, libraries, version conflicts;\n\nFor example\n\n",
        "tags": []
    },
    {
        "uri": "/content/quickguide/_index",
        "title": "Quick Guide",
        "content": "Quick Guide\n\nFollow the guide to start your first journey with HyperMake.\n\nLet's start from Installation\n",
        "tags": []
    },
    {
        "uri": "/content/quickguide/helloworld",
        "title": "Hello World",
        "content": "A Simple Project\n\nLet's make a simple Hello World C++ project,\nand see how HyperMake can help.\n\nHere's the project directory layout:\n\nProjectRoot\n  |\n  +--inc/\n  +--src/\n      +--hello.cpp\n\nIn hello.cpp:\n\ninclude iostream\n\nint main(int argc, char *argv[]) {\n    std::cout << \"Hello World!\" << std::endl;\n    return 0;\n}\n\nTo build it, use g++ -o hello src/hello.cpp.\nProbably you will need to run sudo apt install g++ first on Debian/Ubuntu if\nyou've never installed the toolchain.\nFortunately, using HyperMake, you don't need to worry about that on your host.\n\nThe HyperMake file\n\nHyperMake is a YAML file which sits in the root directory of source tree.\n\n---\nformat: hypermake.v0\nname: hello\ndescription: The Hello World Project\n\n{{% notice tip %}}\nThe first line --- indicates the start of a new document in YAML\n{{% /notice %}}\n\nformat is required and must be hypermake.v0.\n  hmake only accepts YAML files with format: hypermake.v0.\nname specifies the project name, which is required.\ndescription gives more information about the project. It's optional.\n\n Targets\n\nLike make, the minimum execution unit is target:\n\n---\nformat: hypermake.v0\nname: hello\ndescription: The Hello World Project\n\ntargets:\n  build:\n    description: build hello binary\n    image: 'gcc:4.9'\n    cmds:\n      g++ -o hello src/hello.cpp\n\nThe target build is defined. It has three properties:\n\ndescription: a brief intro about what the target does;\nimage: the docker image to create the container and run commands;\ncmds: a list of commands to execute inside the container.\n\nNow, let's do\n\nhmake build\n./hello\n\nIt shows Hello World.\n\nIt always builds even if you don't have g++ installed on the host.\n\nDefault\n\nIf typing hmake build is boring, defining default targets can simplify the\ncommand as a single hmake.\n\n---\nformat: hypermake.v0\nname: hello\ndescription: The Hello World Project\n\ntargets:\n  build:\n    description: build hello binary\n    image: 'gcc:4.9'\n    cmds:\n      g++ -o hello src/hello.cpp\n\nsettings:\n  default-targets:\n    build\n\nNow, typing hmake is equivalent to hmake build.\n\nMore settings can be added.\nFor example all the targets use the same image, it can be moved to settings.\n\n---\nformat: hypermake.v0\nname: hello\ndescription: The Hello World Project\n\ntargets:\n  build:\n    description: build hello binary\n    cmds:\n      g++ -o hello src/hello.cpp\n\nsettings:\n  default-targets:\n    build\n  docker:\n    image: 'gcc:4.9'\n\nAll targets will have image: 'gcc:4.9' by default, unless explicitly specified\nin target.\n\n Watches and Artifacts\n\nLet's do some tricks here: touch src/hello.cpp or modify the file, and then\ntype hmake. You will see the build target is skipped:\n\nHyperMake v1.1.0 https://github.com/evo-cloud/hmake\n\n= build 21:56:42.277\n:] build\n╔══════╤═══════╤════════╤════════════╤════════════╤═════╗\n║Target│Result │Duration│Start       │Finish      │Error║\n╠══════╪═══════╪════════╪════════════╪════════════╪═════╣\n║build │Skipped│        │21:56:42.277│21:56:42.277│     ║\n╚══════╧═══════╧════════╧════════════╧════════════╧═════╝\nOK\n\nThis is definitely not what we want.\nHowever hmake doesn't have the knowledge about source files and output files.\nIt must be explicitly specified using watches and/or artifacts:\n\ntargets:\n  build:\n    description: build hello binary\n    watches:\n      inc\n      src\n    cmds:\n      g++ -o hello src/hello.cpp\n    artifacts:\n      hello\n\nThe items in watches can be a path to a directory or a file, or with wildcards\nmatching a list of files/directories.\nIf the item is a directory, all sub-directories and files are watched recursively.\nartifacts lists the output files.\nWildcard is not allowed here, and directory is not matched recursively.\nhmake rebuilds the target if any of the watched file is changed or\nany artifact is missing.\n\nDependencies\n\nAs the project is so simple that we can use an existing docker image gcc:4.9 which\ncontains toolchain we need.\nHowever in most cases, the public docker images are not always good enough, and\nwe want to install extra bits to build the project.\nThen we need to build our own toolchain image.\n\nLet's use cmake to build our project,\nby adding CMakeList.txt under project root:\n\ncmakeminimumrequired(VERSION 2.8.0)\nproject(hello CXX)\ninclude_directories(\"inc\")\nadd_executable(hello src/hello.cpp)\n\nThen we will need cmake in toolchain image, let's build one based on gcc:4.9.\nCreate a folder toolchain under project root and put a Dockerfile inside it:\n\nProjectRoot\n  |\n  +--inc/\n  +--src/\n  | +--hello.cpp\n  +--toolchain/\n  | +--Dockerfile\n  +--HyperMake\n  +--CMakeList.txt\n\nIn Dockerfile:\n\nFROM gcc:4.9\nRUN apt-get update && apt-get install -y cmake && apt-get clean\n\nAnd update HyperMake:\n\n---\nformat: hypermake.v0\nname: hello\ndescription: The Hello World Project\n\ntargets:\n  toolchain:\n    description: build our own toolchain image\n    watches:\n      toolchain\n    build: toolchain\n\n  build:\n    description: build hello binary\n    after:\n      toolchain\n    watches:\n      inc\n      src\n    cmds:\n      rm -fr rel && mkdir -p rel\n      cd rel && cmake .. && make\n    artifacts:\n      rel/hello\n\nsettings:\n  default-targets:\n    build\n  docker:\n    image: 'cmake-gcc:4.9'\n\nTarget toolchain is added. Property build tells hmake to build a\ndocker image from toolchain/Dockerfile.\nAnd as image: cmake-gcc:4.9 is specified in settings,\nthe built image will be cmake-gcc:4.9.\n\nIn target build, property after specifies toolchain must succeed\nbefore build is able to run.\n\nNow, type hmake and it will first run toolchain to build cmake-gcc:4.9 and\nthe run build to call cmake to build the binary.\n",
        "tags": []
    },
    {
        "uri": "/content/quickguide/install",
        "title": "Installation",
        "content": "Install Docker\n\nInstall Docker, version 1.12.3 or above is required.\n\nRun\n\ndocker version\n\nand make sure it shows both client and server versions correctly.\n\n Docker Compose (Optional)\n\nInstall docker-compose if you want to\nuse compose property in targets.\n\nInstall HyperMake\n\n For Mac\n\nbrew tap evo-cloud/toolkit  # only do this once\nbrew install hmake\n\nOr download and extract the binary directly\n\ncurl -s https://github.com/evo-cloud/hmake/releases/download/v1.3.0/hmake-darwin-amd64.tar.gz | sudo tar -C /usr/local/bin -zx\n\nFor Linux\n\ncurl -s https://github.com/evo-cloud/hmake/releases/download/v1.3.0/hmake-linux-amd64.tar.gz | sudo tar -C /usr/local/bin -zx\n\n For Windows\n\nDownload and extract the binary from\n\nhttps://github.com/evo-cloud/hmake/releases/download/v1.3.0/hmake-windows-amd64.zip\n\nAnything else?\n\nNo. That's all you need. Enjoy!\n",
        "tags": []
    },
    {
        "uri": "/content/references/_index",
        "title": "References",
        "content": "References\n\nThe full specifications OF\n\nCommand Line\nFile Format\nDocker Driver\n",
        "tags": []
    },
    {
        "uri": "/content/references/commandline",
        "title": "Command Line",
        "content": "\nhmake [OPTIONS] [TARGETS]\n\nThere's no specific order between OPTIONS and TARGETS. All OPTIONS starts\nwith hyphen - while TARGETS doesn't.\n\n{{% notice tip %}}\nCommon Unix command line option parsing rule is adopted:\n{{% /notice %}}\n\nA short option starts with a single hyphen and then a single letter\n  (e.g. -C);\n  it may have a corresponding long option which starts with a double hyphen\n  followed by a word (or a few words concated with hyphen)\n  (e.g. --chdir, --this-is-a-multi-word-opt);\nThe value after a short option is provided as a separated argument\n  (after a space, e.g. -C /tmp/proj);\n  for long option, the value follows directly with = in the same argument\n  (e.g. --chdir=/tmp/proj);\nSome option can be specified multiple times to provide a list or a map\n  (e.g.br\n  list: --include=a.hmake --include=b.hmake or -I a.hmake -I b.hmake;br\n  map: --define=ARCH=x8664 --define=OS=linux or -D ARCH=x8664 -D OS=linux\n  );\nBool options can be specified without value as true or prefixed by no- as\n  false (e.g. --verbose for true, --no-verbose for false);\n  It can also be specified with a value in the long option format\n  (e.g. --verbose=true or --verbose=false).\n\nOptions\n\n--chdir=PATH, -C PATH: Chdir to specified PATH before doing anything;\n--file=FILE, -f FILE: Override the default project file name HyperMake;\n  This only specifies the file name, no path included;\n--include=FILE, -I FILE: Include additional files (must be relative path under project root), can be specified multiple times\n--property=key=value, -P key=value: Define property in global settings section, key may include . to specify the hierarchy (e.g. -P docker.image=gcc-5);\n--parallel=N, -p N: Set maximum number of targets executed in parallel, 0 for auto, -1 for unlimited;\n--rebuild-all, -R: Force rebuild all needed targets\n--rebuild-target TARGET, -r TARGET: Force rebuild specified target, this can be specified multiple times;\n--rebuild, -b: Force rebuild targets specified on command line;\n--skip TARGET, -S TARGET: Skip specified target (mark as Skipped), this can be specified multiple times;\n--exec, -x: Execute a shell command in the context of a target.\n  The target name must be specified in settings.exec-target or use --exec-with=TARGET.\n  It's extremely useful to run arbitrary command in the context of a target.\n  It should come as the last option, as the rest command-line arguments will be\n  treated as command.\n\n  For example:\n    hmake -x go version\n  hmake -x    enter an interactive shell inside the container\n  \n  The commands parsing after -x is directly executed by execvp system call,\n  not a command to be parsed by shell. So shell syntax like && won't work.\n\n  To run as a shell command\n    hmake -x /bin/sh -c 'go version || echo \"go version failed\"'\n  \n--exec-with=TARGET, -X TARGET: Explicitly specify the target for --exec instead of\n  fetching from settings.exec-target.\n  As it implies --exec, it should come as the last option.\n\n  For example:\n    hmake --exec-with=vendor go version\n  \n--json: Dump execution events to stdout in single line JSON documents;\n--summary, -s: Show execution summary before exit;\n--quiet, -q: Suppress output from targets;\n--rcfile|--no-rcfile: Load .hmakerc inside project directories, default is true;\n--color|--no-color: Explicitly specify print with color/no-color;\n--emoji|--no-emoji: Explicitly specify print with emoji/no-emoji;\n--no-debug-log: Disable writing debug log to hmake.debug.log in hmake state directory (.hmake);\n--show-summary: When specified, print previous execution summary and exit, without doing anything else;\n--targets: When specified, print list of target names and exit;\n--dryrun: When specified, pretend to run targets in the right order, but without actually execute them (simply mark task Success);\n--version: When specified, print version and exit.\n\nThe parsing of options stops when -- is encountered.\nThe rest of arguments will be treated as target names.\nExcept --exec/--exec-with already implies end of options parsing,\n-- will be interpreted as an argument to exec command.\n\n{{% notice info %}}\n--exec/--exec-with doesn't affect the last execution result of the\ntarget, though it displays the result and updates the summary. The target\nmay still be skipped next time if nothing changed.\n{{% /notice %}}\n\nExit Code\n\n0: Success\n1: One or more targets failed\n2: Incorrect usage\n",
        "tags": []
    },
    {
        "uri": "/content/references/dockerdrv",
        "title": "Docker Driver",
        "content": "This execution driver interprets commands or scripts and run inside docker container\nusing specified image.\nThe driver uses docker run to start the container, not using Docker REST API,\nso docker CLI is required.\n\nProperties\n\nscript: a multi-line string represents a full script to execute inside the\n  container;\n  E.g.\n\n    targets:\n      sample:\n          script: |\n              !/bin/bash\n              echo 'This is a bash script'\n      sample1:\n          script: |\n              #!/usr/bin/env perl\n              print \"a perl script\"\n  \ncmds: when script is not specified, this is a list of commands to execute\n  for the target; E.g.\n\n    targets:\n      sample:\n          cmds:\n              mkdir -p bin\n              gcc -o bin/hello hello.c\n  \n  the list of commands is merged to generate a shell script:\n\n    #!/bin/sh\n  set -e\n  mkdir -p bin\n  gcc -o bin/hello hello.c\n  \nenv: a list of environment variables (the form NAME=VALUE) to be used for\n  execution (the -e option of docker run); E.g.\n\n    targets:\n      sample:\n          env:\n              ARCH=x86_64\n              OS=linux\n              RELEASE        # without =VALUE, the value is populated from\n                               # current environment of hmake\n  \n{{% notice tip %}}\nIt's very useful to specify environment variable without a value.\nIt's possible to specify the value at the time invoking hmake, instead of hard-code\nin hmake files.\n{{% /notice %}}\n\nenv-files: list of files providing environment variables, see --env-files\n  of docker run;\n\nconsole: when true, the current stdin/stdout/stderr is directly passed to\n  command which is able to fully control the current console, equivalent to\n  docker run -it.\n  Default is false, equivalent to docker run -a STDOUT -a STDERR.\n\n{{% notice info %}}\nWhen console is enabled, no output is captured or logged.\n{{% /notice %}}\n\nbuild: path to Dockerfile, when specified, this target builds a docker\n   image first. image property specifies the image name and tag.\n   The value can point to a Dockerfile (e.g. build: build/Dockerfile.arm)\n   which indicates the folder containing the file is the context folder.\n   And the value can also point to a folder which contains a Dockerfile\n   (e.g. build: build) which uses the folder as context folder and looks for\n   Dockerfile there.\n\n{{% notice tip %}}\nDockerfile and any related files should be included in watches list\n{{% /notice %}}\n\nbuild-from: the path of context folder for docker build.\n  Without this property, the path is derived from path of Dockerfile specified\n  in build. Please note, the path must be direct/indirect parent of the\n  Dockerfile as required by docker build;\n\nbuild-args: list of args, corresponding to docker build option;\n\nimage: with build it's the image name and tag to build,\n  without build, it's the image used to create the container;\n\ntags: a list of tags in addition to image when do docker build;\n\ncommit: commit running container into new image. Support multiple tags.\n  Image tag will be latest, if not self-defined in image name. E.g.\n\n    target:\n      image: image-name:tag\n      cmds:\n          Some commands\n          ...\n      commit:\n            new-image-name:tag1\n            new-image-name:tag2\n  \n  It will first run the commands in the container created from image-name:tag\n  and then commit the container to image new-image-name:tag1, new-image-name:tag2.\n  It's the alternative way to build an image, versus using property build.\n\ncache: only used to specify false which adds --no-cache to docker build;\ncontent-trust: only used to specify false which adds\n  --disable-content-trust to docker build/run;\nsrc-volume: the full path inside container where project root is mapped to.\n  Default is /src;\nexpose-docker: when set true, expose the host docker server connectivity\n  into container to allow docker client run from inside the container.\n  This is very useful when docker is required for build and avoid problematic\n  docker-in-docker;\nprivileged: run container in privileged mode, default is false;\nnet: when specified, add --net option to docker CLI.\n  When set to host, also add --uts=host;\nlink: a list of strings of container:hostname mapping to --link option.\n  This is very useful when combined with compose (docker-compose);\nuser: passed to docker run --user..., by default, current uid:gid are\n  passed (with docker-machine the uid:gid is queried from the virtual machine\n  running docker daemon).\n  It must be explicitly specified root if the script is executed as root\n  inside container.\n  When a non-root user is explicitly specified, all group IDs are automatically\n  passed using --group-addl;\ngroups: explicitly specify group IDs to pass into container, instead of\n  passing all of them;\nvolumes: a list of volume mappings passed to -v option of docker run;\ncompose: run docker-compose, see below for details.\n\nThe following properties directly maps to docker build/run options:\n\ncap-add, cap-drop\ndevices\nhosts: mapped to --add-host\ndns, dns-opts, dns-search\nblkio-weight, blkio-weight-devices\ndevice-read-bps, device-write-bps, device-read-iops, device-write-iops\ncpu-shares, cpu-period, cpu-quota, cpuset-cpus, cpuset-mems\nkernel-memory, memory, memory-swap, memory-swappiness, shm-size\nulimit\nlabels, label-files\npull, force-rm\n\nAll above properties can also be specified in settings/local under\ndocker section:\n\nsettings:\n    docker:\n        property: value\n\nVolume Mapping\n\nBy default the current project root is mapped into container at src-volume,\ndefault value is /src.\nAs the script is a shell script, the executable /bin/sh must be present in\nthe container.\n\nThe host side path is translated with the following rule:\n\nIt's relative path, it's relative to working directory (property workdir);\nIt's absolute path (including starting with ~/, ~ expands to home), it's absolute on the host;\nIt starts with -/, it's relative to project root.\n\nExample:\n\ntargets:\n  volumes:\n    'abc:/var/lib/abc'   host path is $HMAKEPROJECTDIR/$HMAKETARGETDIR/abc\n    '~/.ssh:/root/.ssh' # host path is $HOME/.ssh\n    '/var/lib:/var/lib' # host path is /var/lib\n    '-/src:/src'        # host path is $HMAKEPROJECTDIR/src\n\n{{% notice info %}}\nOn Mac OS, only paths under /Users can be mapped into the container.\nAll project trees must sit under /Users.\n{{% /notice %}}\n\n{{% notice info %}}\nOn Windows, only paths under C:\\Users can be mapped into the container.\nAll project trees must sit under C:\\Users.\n{{% /notice %}}\n\nUser\n\nBy default hmake uses current user (NOT root) to run inside container,\nwhich make sure any file change has the same ownership as the environment outside.\nIf root is required, it can be explicitly specified user: root,\nhowever, all files created inside container will be owned by root outside,\nand you may eventually see some error messages like permission denied when you\ndo something outside.\n\n Docker Compose\n\nThe property compose is used to run docker-compose as a background target.\nThe value can be a single string pointing to a directory containing\ndocker-compose.yml (docker-compose.yaml) or a full path to a file with\nalternative name instead of docker-compose.yml,\nor an object containing detailed properties:\n\nfile: the path to a directory containing docker-compose.yml, or to a file\n  with alternative name;\nproject-name: override project name (--project-name);\ndeps: when false, add --no-deps;\nrecreate: when false, add --no-recreate, or force, add --force-recreate;\nbuild: when true, add --build, or false, add --no-build;\nremove-orphans: when true, add --remove-orphans;\nservices: a list of strings as service names after docker-compose up command line.\n\nWhen compose is present, the target is executed as a background target.\ndocker-compose up -d is used to launch containers in the background.\nIf cmds or build are also present in the same target, they are executed after\ndocker-compose launched the containers.\n\nOther targets can take dependency on a background target (e.g. with compose), and\nin this case, use net and link to connect target to containers launched by\ndocker-compose. This is very useful to launch a testing environment and run\ntest code from targets.\n\nKnown Issues\n\nDocker machine backed by VirtualBox: Docker for Mac is recommended instead of VirtualBox\n    Unstable NAT service: the NAT service from VirtualBox will eventually disconnect;\n    Hard link not supported: hard links can't be created on mapped volumes;\nTime drifting inside the VM: with Docker for Mac, the time may drift because there's\n  no time synchronization at current stage;\nMemory exhaust: observed with Docker for Mac, restart Docker service solve the problem;\nDocker --label bug: Docker 1.12 has a bug parsing command line --label which works\n  with Docker 1.11, putting labels inside Dockerfile works fine.\n\n Limits\n\nOn Linux, docker-machine is not supported, docker daemon must run on the same\nhost running hmake.\n",
        "tags": []
    },
    {
        "uri": "/content/references/fileformat",
        "title": "File Format",
        "content": "for wrapper mode, please refer to Wrapper Mode\n\nFile HyperMake must be present in root directory of the project tree.\nCommand hmake can be invoked in any sub-directories inside the project tree\nand it will locate the root of project by looking up HyperMake.\nAdditional files must be named as *.hmake for being referenced in includes\nsection.\nAll these files share the same format.\n\nIn HyperMake or *.hmake, define the following things:\n\nFormat: the format presents the current file, should always be hypermake.v0;\nName and description: only defined in top-level HyperMake file;\nTargets: the target to build, including dependencies and commands;\nSettings: the settings applies to hmake and should be merged into a global view;\nLocal Settings: the settings only apply to current HyperMake or .hmake file;\nIncludes: include more *.hmake files.\n\nHere's the schema in example (this is from the HyperMake file of hmake project):\n\n---\nformat: hypermake.v0 # this indicates this is a HyperMake file\n\nproject name and description\nname: hmake\ndescription: HyperMake builds your project without pre-requisites\n\n define targets\ntargets:\n    builder:\n        description: build the docker image including toolchain\n        build: builder\n        image: hmake-builder:latest\n        watches:\n            builder\n\n    vendor:\n        description: pull all vendor packages\n        after:\n            builder\n        watches:\n            'vendor/manifest'\n        cmds:\n            gvt restore\n\n    # target hmake-linux- will be expanded to three target architectures\n    hmake-linux-[arch:amd64,arm,arm64]:\n        description: static linked hmake binary for linux-$[arch]\n        after:\n            vendor\n        watches:\n            '*/*/*.go'\n            build.sh\n        cmds:\n            ./build.sh linux $[arch]\n        artifacts:\n            bin/linux/$[arch]/hmake\n            bin/hmake-linux-$[arch].tar.gz\n            bin/hmake-linux-$[arch].tar.gz.sha256sum\n\n    hmake-darwin-amd64:\n        description: static linked hmake binary for Mac OS\n        after:\n            vendor\n        watches:\n            '*/*/*.go'\n            build.sh\n        cmds:\n            ./build.sh darwin amd64\n        artifacts:\n            bin/darwin/amd64/hmake\n            bin/hmake-darwin-amd64.tar.gz\n            bin/hmake-darwin-amd64.tar.gz.sha256sum\n\n    hmake-windows-amd64:\n        description: static linked hmake binary for Windows\n        after:\n            vendor\n        watches:\n            '*/*/*.go'\n            build.sh\n        cmds:\n            ./build.sh windows amd64\n        artifacts:\n            bin/windows/amd64/hmake.exe\n            bin/hmake-windows-amd64.zip\n            bin/hmake-windows-amd64.zip.sha256sum\n\n    site:\n        description: generate document site\n        after:\n            builder\n        watches:\n            site/gh-pages\n            '!site/gh-pages/public'\n            build.sh\n        cmds:\n            ./build.sh gensite\n\n    checkfmt:\n        description: check code format\n        after:\n            builder\n        always: true\n        cmds:\n            ./build.sh checkfmt\n\n    lint:\n        description: check code using metalint\n        after:\n            builder\n        always: true\n        cmds:\n            ./build.sh lint\n\n    check:\n        description: check source code\n        after:\n            checkfmt\n            lint\n\n    test:\n        description: run tests\n        after:\n            vendor\n        always: true\n        cmds:\n            ginkgo ./test\n\n    cover:\n        description: run tests with coverage\n        after:\n            vendor\n        always: true\n        cmds:\n            \n                go test -coverprofile cover.out\n                -coverpkg ./project\n                ./test\n\n    e2e:\n        description: end-to-end tests\n        after:\n            vendor\n        expose-docker: true\n        always: true\n        cmds:\n            ginkgo ./test/e2e\n\n    all:\n        description: the default make target\n        after:\n            hmake-linux-amd64\n            hmake-darwin-amd64\n            hmake-windows-amd64\n\ndefine some special targets which can be used as commands\ncommands:\n    echo:\n        description: simple echo command\n        cmds:\n            'echo $@'\n\n settings shared across targets\nsettings:\n    default-targets:\n        all\n    docker:\n        image: hmake-builder:latest\n        src-volume: /go/src/github.com/evo-cloud/hmake\n\nsame as settings, but only apply to targets in the same file\nlocal:\n    key: value\n\nincludes:\n    build/*/*/*.hmake\n\n Format\n\nThe format of this YAML file is indicated by format property which is\nmandatory and the current acceptable value is hypermake.v0\n\nName and Description\n\nThese are optional properties, while it's recommended name should be provided\nas project name.\n\n Targets\n\nThe property targets defines a dictionary of named targets.\nA target is a set of properties to define what to do (a script or a list of commands).\nUsually, it defines\n\nThe environment to execute the script/commands,\n  like docker image, workdir, and options for docker run;\nThe dependencies between targets, using before and after properties;\nWatch of files and artifacts to decide whether the target should be rebuilt.\n\nCommands\n\nCommands are special type of targets, when used, it must be the first non-option\nargument in command line.\n\nE.g.\n\nhmake name arg1 arg2\n\nIf name is defined in commands,\nthe rest of arguments in the command line is passed as arguments to command target name.\n\nCommands are targets, with a few restrictions:\n\nCommands should not be dependency of others. So before is not allowed, and\n  other targets/commands should not after a command;\nCommand can only be used as the first non-option argument in hmake command line\n  which turns on command mode. In the case hmake target1 cmd1, it refuses to\n  run because cmd1 is a command but not come first.\n\n Common Properties in Target\n\ndescription: description of the target;\nbefore: a list of names of targets which can only execute after this target;\nafter: a list of names of targets on which this targets depends;\nworkdir: the current working directory for commands in the target,\n  relative to .hmake file defining the target;\n  if it's absolute (starting with /), it's relative to project root;\n  by default, it's the current directory containing the .hmake file.\nwatches: a list of path/filenames wildcard supported\n  whose mtime will be checked to determine if the target is out-of-date,\n  without specifying this property,\n  the target is automatically skipped if the last execution was successful\n  and all dependencies are skipped;\n  any path/filenames prefixed with ! will be excluded\n  (must be quoted, or ! will be interpreted by YAML).\nalways: always build the target regardless of last execution state and results\n  of all dependencies (the .PHONY target in make);\nartifacts: a list of files/directory must be present after the execution of\n  the target (aka. the output of the target), in relative path to current .hmake\n  file, or if it's absolute path, it's relative to project root.\n\nOther properties are specific to execution driver which executes the target.\nThe currently supported execution driver is docker, please read\nDocker Driver for details.\n\nDependencies\n\nDependencies are specified using:\n\nafter: the target is executed when the depended tasks succeed or are skipped\nbefore: the target must succeed or skip before the specified tasks get executed.\n\nA skipped target means there's nothing to do with the target (no commands or\nit's still up-to-date). It can be an equivalent to success.\n\nIn most cases, after is enough. before is often used to inject dependencies.\n\n Matching targets names with wildcards\n\nThe places (before, after, -r, -S, command line targets, etc) requiring\ntarget names accept wildcards:\n\nWildcards used in file names: *, ?, \\ and [chars], they are matched using filepath.Match\nRegular Expression: the name starts and ends with /\n\nPre-defined Environment Variables\n\nThese environment variables can be used in each targets.\n\nHMAKEPROJECTNAME: the name of the project;\nHMAKEPROJECTDIR: the directory containing HyperMake (aka. project root);\nHMAKEPROJECTFILE: the full path to HyperMake, including file name;\nHMAKEWORKDIR: $HMAKEPROJECTDIR/.hmake;\nHMAKELAUNCHPATH: the relative path under $HMAKEPROJECTDIR where hmake launches\nHMAKEREQUIREDTARGETS: the names of targets explicitly required from command line, separate by space\nHMAKE_TARGET: the name of the target currently in execution\nHMAKETARGETDIR: the relative path to directory containing the HyperMake\n   or *.hmake file which defines the target\nHMAKEVERSION: version of _hmake\nHMAKE_OS: operating system\nHMAKE_ARCH: CPU architecture\n\n Target Expansions\n\nTarget Expansion is useful when defining multiple targets with similar properties.\nFor example cross compiling for multiple targets, most of the properties are identical\nonly OS and CPU arch is different. In stead of duplicate the same blocks for each\ntarget, writing one target with expansion syntax in target name, and hmake will help\ngenerate multiple targets using expansion information.\n\nIn above example:\n\ntargets:\n    hmake-linux-[arch:amd64,arm,arm64]:\n        description: static linked hmake binary for linux-$[arch]\n        after:\n            vendor\n        watches:\n            '*/*/*.go'\n            build.sh\n        cmds:\n            ./build.sh linux $[arch]\n        artifacts:\n            bin/linux/$[arch]/hmake\n            bin/hmake-linux-$[arch].tar.gz\n            bin/hmake-linux-$[arch].tar.gz.sha256sum\n\nThe target hmake-linux-[arch:amd64,arm,arm64] will be expanded into three targets:\n\nhmake-linux-amd64\nhmake-linux-arm\nhmake-linux-arm64\n\nWith $[arch] substituted accordingly in each expanded targets.\n\nThe syntax is simple: [var-name:val1,val2,...] to define an expansion variable\nwith possible values, and in the properties, $[var-name] will be substituted.\nIf var-name is not defined in target name, $[var-name] will NOT be substituted.\nSpecially, $[$] substitutes to $.\n\nMultiple variables can be defined, example:\n\ntarget-[os:linux,darwin]-[arch:386,amd64]\n\nwill expand to\n\ntarget-linux-386\ntarget-linux-amd64\ntarget-darwin-386\ntarget-darwin-amd64\n\nInclude Files\n\nIn includes section, specify files to be included.\nThe files included can provide more targets and also override settings.\nPath wildcard can be used.\n\nAny path used in HyperMake or *.hmake files are relative to current file.\nWhen a target gets executed, the default working directory is where the file\ndefining the target exists.\n\n Settings\n\nIn settings section, the hierarchical dictionary is used to provide\nglobal settings. According to the order of *.hmake files loaded, the file loaded\nlatter overrides the settings in the former loaded files.\nIn local section, the settings are only applied to current file.\nAnd the properties defined in target overrides everything.\n\nHere's the order hmake looks a setting by name:\n\nFrom target's properties;\nFrom local;\nFrom settings in the reversed order of files being loaded.\n\nPre-defined Setting Properties\n\ndefault-targets: a list of targets to build when no targets are specified\n  in hmake command;\ndocker: a set of docker specific properties which defines\n   default values for targets.\n\n Local Customization\n\nAfter loading HyperMake and *.hmake files, hmake also looks up .hmakerc\nfiles from current directory up to root directory of the project and load them\nin the order from root directory down to the current directory.\nThe .hmakerc has the same format as HyperMake and *.hmake files and is\nused to override settings and inject targets to satisfy the special needs of\nlocal development environment.\n\n{{% notice tip %}}\n.hmakerc SHOULD be included in .gitignore file.\n{{% /notice %}}\n\nPath Wildcard\n\nhmake supports wildcards in paths, e.g.\n\nfn: matches files/directories in current level;\n*/*fn: matches files/directories in any sub-directories;\n*/*/*fn: matches files/directories in any levels of sub-directories.\n",
        "tags": []
    },
    {
        "uri": "/content/tutor/_index",
        "title": "Tutorials",
        "content": "Tutorials\n\nThe tutorials covers common use cases with hmake:\n\n Basis\n\nA HyperMake Project\nTarget Execution\n\nCommon Practice\n\nBuild Docker Image\nPush Docker Image\nDocker Compose\nExec Mode\nCommand Mode\nMap Credentials\nTarget Expansion\nWrapper Mode\n\n Others\n\nFAQ\n",
        "tags": []
    },
    {
        "uri": "/content/tutor/buildimage",
        "title": "Build Docker Image",
        "content": "It's simple and straight-forward to build Docker images using hmake.\n\nUse Docker build\n\n---\nformat: hypermake.v0\nname: build-sample\n\ntargets:\n  build-image:\n    description: build docker image\n    build: dir-contains-Dockerfile\n    image: 'my-image:tag'\n    tags:\n      'my-image1:tag1'\n      'my-image2:tag2'\n\nSpecify property build to run docker build for the target.\nThe value can be a path to a directory containing Dockerfile,\nor path including filename.\nIf filename is included, it's not necessary to be Dockerfile,\nhmake will take care of the right command line arguments to docker build.\n\nThe image property specifies the final image name,\nadditional tags can be specified using tags property.\n\nFor more properties, please refer to\nDocker Driver\nreference for details.\n\n Use Docker Commit\n\nThis is the alternate approach of building a docker image without using\ndocker build or Dockerfile.\nIt's a normal target with commit property.\n\n---\nformat: hypermake.v0\nname: build-sample1\n\ntargets:\n  build-image:\n    description: build docker image\n    image: base-image\n    cmds:\n      ./setup.sh\n    commit: 'my-image:tag'  \n\nFirst, as a normal target, it runs ./setup.sh inside container.\nThe script may install software or modify the file system of the container\ncreated from base-image.\nWhen the script finishes, the container is committed to image my-image:tag\nas specified by property commit.\n\nThe value of commit can be a single image name or a list of image names, like:\n\n---\nformat: hypermake.v0\nname: build-sample1\n\ntargets:\n  build-image:\n    description: build docker image\n    image: base-image\n    cmds:\n      ./setup.sh\n    commit:\n      'my-image:tag'  \n      'my-image1:tag1'\n      'my-image2:tag2'\n\nAs Base Image\n\nThe image built can be used as base image for other targets.\nFor most projects, a common practice is create a toolchain image and used by\nall other targets.\n\n---\nformat: hypermake.v0\nname: common-project\n\ntargets:\n  toolchain:\n    description: build toolchain image\n    build: toolchain\n\n  build:\n    description: build from source\n    after:\n      toolchain\n    cmds:\n      ./build.sh\n\n  test:\n    description: test the build\n    after:\n      build\n    cmds:\n      ./test.sh\n\nsettings:\n  docker:\n    image: mytoolchain\n",
        "tags": []
    },
    {
        "uri": "/content/tutor/commandmode",
        "title": "Command Mode",
        "content": "\nOverview\n\nSimilar to make, the command line arguments are interpreted as targets name\nfor hmake.\nIn addition to that, hmake introduces a special type of targets - commands.\nWhen these targets are invoked, the command line arguments will be passed through\nto the target as arguments.\n\nSee File Format for details.\n\n---\nformat: hypermake.v0\n\ntargets:\n  build:\n    description: build the source code\n    cmds:\n      ./build.sh\n\ncommands:\n  pack-for:\n    description: pack for specified target\n    after:\n      build\n    cmds:\n      './pack.sh $1'\n\nWhen invoke\n\nhmake pack-for ubuntu\n\nWill execute target pack-for and the rest of the command line is passed as\narguments to the target.\nFrom HyperMake, it's possible to reference the arguments, like $1, in\ncommand targets.\n\n Restrictions\n\nCommand targets are special, with restrictions:\n\nIt can depends on normal targets, but can't be a dependency;\nIt must be the first argument on hmake command line.\n",
        "tags": []
    },
    {
        "uri": "/content/tutor/compose",
        "title": "Docker Compose",
        "content": "\nhmake supports docker-compose\nout-of-box, using property compose.\n\n---\nformat: hypermake.v0\nname: compose-sample\n\ntargets:\n  build:\n    description: build from source code\n    cmds:\n      ./build.sh\n    artifacts:\n      out/service/Dockerfile\n      out/service/service.bin\n      out/service-compose/docker-compose.yml\n\n  pack:\n    description: pack as docker image\n    after:\n      build\n    build: out/service\n    image: 'myservice:latest'\n\n  start:\n    description: start built service in background\n    after:\n      pack\n    compose: out/service-compose\n\n  test:\n    description: test against service\n    after:\n      start\n    link:\n      'service:service'\n    cmds:\n      ./test.sh\n\nPlease refer to Background Target, Docker Driver for details.\n",
        "tags": []
    },
    {
        "uri": "/content/tutor/execmode",
        "title": "Exec Mode",
        "content": "\nexec mode allows execution of arbitrary command inside the container under\nthe context of the specified target.\n\nOverview\n\n---\nformat: hypermake.v0\n\ntargets:\n  build:\n    description: build the source code\n    cmds:\n      ./build.sh\n    env:\n      FLAG=1\n\n  test:\n    description: run test\n    cmds:\n      ./test.sh\n\nsettings:\n  exec-target: build\n  docker:\n    image: 'ubuntu:latest'\n\nSometimes, developers need to get into the execution environment of a target to\nfind out what goes wrong.\nexec mode is designed for this specific needs.\n\nWith above HyperMake, run\n\nhmake -x\n\nIt will bring up a shell /bin/sh inside the container under the context of\nbuild target.\n\nThe default shell is /bin/sh, to override it, specify exec-shell in settings:\n\n---\nsettings:\n  exec-shell: /bin/bash\n\nThe shell is brought up in interactive mode, that means hmake will run in\ninteractive mode, printing build progress of all dependencies, and run the\ntarget in a TTY (docker run -it).\n\nAn arbitrary command can be specified instead of invoking an interactive shell.\nIn this case, hmake works in non-interactive mode, only the stdout/stderr of\nthe target will be printed on the console.\n\nhmake -x sh -c 'echo $FLAG'\n\nIt will print 1.\n\n{{% notice info %}}\nIf command is specified, it's a exec command line, not interpreted by shell\n{{% /notice %}}\n\n Alternative Target Context\n\nBy default, -x will use target context specified by exec-target.\nIf a different target context is needed, use -X target:\n\nhmake -X test\nhmake -X test command arg1 arg2 ...\n\n{{% notice info %}}\nOption -x and -X indicates the end of option parsing from the command line,\nso they must be the last option, and -- should not be used after that.\nIf used, -- will be directly interpreted as common/argument to execute.\n{{% /notice %}}\n\nRun as root\n\nUsually target specified by exec-target doesn't run as root.\nHowever it's useful to run hmake -x as root user, for example inspecting\ninstalled packages and checkout new packages etc.\n\nUse settings property to override this\n\nhmake -P docker.user=root -x\n",
        "tags": []
    },
    {
        "uri": "/content/tutor/faq",
        "title": "FAQ",
        "content": "*Q*: Why I can't git clone private repositories?br\n  *A*: HyperMake runs the build inside containers which may not have the right\n  SSH keys or credentials. There're two options:\n\n  Mapping ~/.ssh into the container using volumes property:\n\n        volumes:\n      '~/.ssh:/src/.ssh:ro'\n      Mapping ~/.netrc into the container:\n\n    first, create a file ~/.netrc. See the\n    manual\n    for the format and content. E.g.\n\n        machine github.com\n    protocol https\n    login username\n    password password\n    \n    Then use volumes property to map into the container.\n\n        volumes:\n      '~/.netrc:/src/.netrc:ro'\n    \n*Q*: Can I build projects for Windows?br\n  *A*: Depending on toolchain. HyperMake builds on Linux, for C/C++,\n install mingw toolchain in the container and do\n the cross complication.\n\n*Q*: Can I build projects for native Mac OS?br\n  *A*: Depending. If it's a project in Go, yes. If it depends on native Mac OS\n  libraries, it's possible when cross compiling toolchain and libraries are\n  installed on Linux.\n\n*Q*: Why target is skipped but output file is not present?br\n  *A*: Property artifacts is not specified in the target. HyperMake checks\n  both input and output files to determine if a target is up-to-date. Property\n  watches lists the input files whose last modification time is checked, and\n  property artifacts lists the output files whose presence is checked.\n  If artifacts is not specified, HyperMake assumes the target doesn't generate\n  output files.\n\n*Q*: What's the artifacts if the target doesn't output files?br\n  *A*: No need to specify artifacts if there's no output file. Some targets\n  like docker build doesn't output files, it will automatically check if the\n  image exists. To explicitly rebuild the target, use -r TARGET, -b or -R\n  options.\n\n*Q*: I want to run some commands, which are specific to my local environment,\n  before certain targets. But I don't want to put them in HyperMake file.br\n  *A*: You can create a .hmakerc in project root, and exclude that file using\n  .gitignore. The settings in .hmakerc will override those in HyperMake\n  and use before to inject your local targets into HyperMake, e.g.\n\n    ---\n  format: hypermake.v0\n  targets:\n    pre-build:\n      description: my local task before build\n      before:\n        build\n      cmds:\n        do something\n  settings:\n    property: my-value\n  \n*Q*: How to map a volume from a folder relative to project root?br\n  *A*: In top-level HyperMake, use relative path for source of the volume,\n  in *.hmake files under sub-directories, prefix -/ to a relative path. E.g.\n\n    targets:\n    example:\n      volumes:\n        '-/run:/var/run'\n  \n  Anyway, in volumes, prefix -/ can always be used to indicate a path\n  relative to project root. Please read Docker Driver for\n  details.\n\n*Q*: Where can I find the output of my target after running hmake?br\n  *A*: hmake creates a hidden folder .hmake under project root. The output\n  of a target is saved in .hmake/TARGET.log.\n\n*Q*: Does hmake print logs?br\n  *A*: Yes. hmake writes its own debug logs in .hmake/hmake.debug.log.\n\n*Q*: What're the recommended entries in .gitignore?br\n  *A*: Put the following entries in .gitignore:\n\n    .hmake\n  .hmakerc\n  ",
        "tags": []
    },
    {
        "uri": "/content/tutor/mapcreds",
        "title": "Map Credentials",
        "content": "Problem\n\nMany CLI tools like docker, aws-cli, gcloud etc stores credentials in user's home\ndirectory.\nWhen build directly from the host, there's no problem accessing these services.\nHowever, using hmake, build runs inside container which doesn't have the right\ncredentials, and will fail.\n\n Solution\n\nHere's a commonly used practice to map credentials from local home directory.\n\n---\nformat: hypermake.v0\nname: map-credentials\n\ntargets:\n  build:\n    description: build source code\n    cmds:\n      ./build.sh\n    env:\n      HOME=/tmp\n    volumes:\n      '~/.ssh:/tmp/.ssh:ro'\n      '~/.aws:/tmp/.aws:ro'\n",
        "tags": []
    },
    {
        "uri": "/content/tutor/project",
        "title": "A HyperMake Project",
        "content": "Project Layout\n\nA HyperMake project requires one HyperMake file in root directory of the\nproject (The file name can be overridden using --file|-f,\nsee Command Line for details).\nThe command hmake can be invoked in any sub-directory of the project and it will\nlook up HyperMake to determine the root of project.\n\nSimilar to a Makefile, HyperMake defines targets with dependencies\n(see File Format).\nTo better organize the targets, it's possible to break targets into multiple files.\nFiles other than the root HyperMake are modules and named with suffix\n.hmake.\nUse includes section to include all modules into one HyperMake file.\n\nProjectRoot\n  |\n  +--module1/\n  | +--module.hmake\n  +--module2/\n  | +--module.hmake\n  +--HyperMake\n  +--.gitignore\n\nIn HyperMake\n\n---\nformat: hypermake.v0\nname: sample\n\nincludes:\n  */*/*.hmake\n\nname is required in root HyperMake, but not in *.hmake modules.\n\nIn .gitignore, the following two lines are recommended:\n\n.hmake\n.hmakerc\n\n State Directory\n\nWhen hmake runs, it will create a state folder .hmake in the project root directory.\nWithin the folder, it tracks the execution result of targets, hmake logs,\noutput of targets, checksum of mtime of watched files and artifacts, and\nalso other files including generated scripts.\n\nIn most cases, this directory is irrelevant to the project and can be safely ignored.\nHowever, it's very useful for analyzing the scripts/logs if something goes wrong.\n\nLocal Modules\n\nhmake respects special files named .hmakerc when they are present.\nThey are the same as modules (*.hmake), but loaded after them.\nThe files specified after --include|-I are treated the same way but loaded last.\n\nHere's the order to load files:\n\nLoad HyperMake in project root;\nLoad all modules from includes section, recursively;\nFind and load .hmakerc files from the folder launching hmake up to project root;\nLoad files specified by --include|-I\n\nUsually, .hmakerc and files specified by --include|-I are excluded from\nbeing committed to source control (in .gitignore), and are called local modules.\nThese files are used to override settings and\ninject dependencies for\nthe local needs of a developer.\n\n{{% notice info %}}\nLocal modules can override settings, inject dependencies, defining additional targets.\nExisting targets can't be overridden/redefined.\n{{% /notice %}}\n\n Targets\n\nTargets are the basic execution units of a HyperMake project.\nThey are defined in targets section:\n\n---\nformat: hypermake.v0\n\ntargets:\n  build:\n    description: build the source code\n    cmds:\n      ./build.sh\n\nTargets have dependencies, which are defined using before and after:\n\n---\nformat: hypermake.v0\n\ntargets:\n  toolchain:\n    description: build docker image contains toolchain\n    build: toolchain\n  build:\n    description: build the source code\n    after:\n      toolchain\n    cmds:\n      ./build.sh\nsettings:\n  docker:\n    image: mytoolchain\n\nWhen run hmake build, toolchain will execute before build.\n\nbefore means the opposite, and is mostly used for dependency injection.\n\nDependency Injection\n\nThis usually happens in .hmakerc and files specified by --include|-I.\nIn the file, define a target with before property, e.g. in .hmakerc\n\n---\nformat: hypermake.v0\n\ntargets:\n  pre-build:\n    description: hook before build\n    after: toolchain\n    before: build\n    cmds:\n      patch some files\n",
        "tags": []
    },
    {
        "uri": "/content/tutor/pushimage",
        "title": "Push Docker Image",
        "content": "\nhmake provides built-in support to push docker image to a remote registry.\n\n---\nformat: hypermake.v0\nname: push-sample\n\ntargets:\n  build-image:\n    description: build docker image\n    build: Dockerfile\n    image: 'myimage:tag'\n    tags:\n      'registry:5000/namespace/myimage:tag'\n      'registry1/namespace/myimage:tag'\n\n  push-image:\n    description: push docker images\n    after:\n      build-image\n    push:\n      'registry:5000/namespace/myimage:tag'\n      'registry1/namespace/myimage:tag'\n\nThe property push specifies which images to push.\nhmake calls docker push locally to push the images,\nso make sure the credentials are stored using docker login if the registry\nrequires authentication.\n",
        "tags": []
    },
    {
        "uri": "/content/tutor/targetexec",
        "title": "Target Execution",
        "content": "For full specification of all properties, please refer to\n\nFile Format\nDocker Driver\n\nHow Target Executes\n\nA target always executes inside Docker container.\n\n---\nformat: hypermake.v0\nname: hello\ndescription: The Hello World Project\n\ntargets:\n  build:\n    description: build hello binary\n    image: 'gcc:4.9'\n    cmds:\n      g++ -o hello src/hello.cpp\n      strip hello\n\nIn the above example, a container is created using image gcc:4.9 as specified\nby property image.\nAnd lines in cmds are merged into a shell script .hmake/build.sh:\n\n!/bin/sh\nset -e\ng++ -o hello src/hello.cpp\nstrip hello\n\nFinally, the execution is equivalent to invoke\n\ndocker run -a STDOUT -a STDERR -v pwd:/src -w /src gcc:4.9 /bin/sh .hmake/build.sh\n\nSource Tree Mapping\n\nAs targets are executed inside containers, the complete source tree of the project\nis mapped into the container read-write\n(details here).\nSo all source files can be accessed inside container, and modifications in the\nsource tree is actually on the host.\n\nThe default path inside the container is /src and can be overridden using\nproperty src-volume in target.\n\nAll file/path references are restricted inside project source tree\n(except docker volume mapping volumes property in targets).\n\n Execution Order\n\nTargets are executed according to the dependencies defined using before and\nafter.\nWhen possible, hmake will execute targets in parallel if dependencies are\nsatisfied.\n\nIf any target fails, hmake will wait until all running targets finishes and exit.\nIt fails fast, and won't continue other ready-to-run targets.\n\nWatches and Artifacts\n\nhmake has no knowledge about input/output of a target.\nThough in certain situation like build docker image, the execution driver\nis able to figure out the output, for most targets, it's impossible for hmake\nto find out automatically.\n\nTo rebuild the target only on relevant changes,\nproperties watches and artifacts are introduced to explicitly specify what\nare the inputs and what are the outputs.\n\n---\nformat: hypermake.v0\nname: hello\ndescription: The Hello World Project\n\ntargets:\n  build:\n    description: build hello binary\n    image: 'gcc:4.9'\n    watches:\n      inc\n      src/*/*/*.cpp\n      !inc/*/*/*.hpp\n    cmds:\n      g++ -o hello src/hello.cpp\n    artifacts:\n      hello\n\nProperty watches specifies a list of source files and accepts\nwildcard\nWhen the item is a directory, all files and sub-directories are watched\nrecursively.\nWith ! prefixed, the item specifies files/directories to be excluded.\n\nProperty artifacts specifies the expected output files/directories of the target.\nUnlike watches, wildcard is not allowed, and if the item is a directory,\nit's not scanned for files and sub-directories underneath.\n\nWith these information, hmake will track the mtime of watched files,\nand determine whether the target can be simply skipped if no change was made\nand artifacts are all available.\n\nWithout these information, or the information is not properly specified,\nhmake may incorrectly skip the target even some change was made.\n\nSometimes, certain targets must always be built regardless of changes.\nIn this case, specifying property always to true forces hmake build\nthe target every time.\nThis is especially useful for targets running tests, lint, etc.\n\n---\nformat: hypermake.v0\nname: hello\ndescription: The Hello World Project\n\ntargets:\n  test:\n    description: run test\n    always: true\n    cmds:\n      ./test.sh\n\n  lint:\n    description: run lint\n    always: true\n    cmds:\n      ./run_lint.sh\n\n Background Targets\n\nBackground targets are those targets which spawn processes and keep them running\nin the background.\nIt's very useful to spin up a testing environment with a few background targets\nand one of the test target runs testing code against these background targets.\n\nThe background targets are implemented using\ndocker-compose.\n\nE.g.\n\n---\nformat: hypermake.v0\nname: compose-sample\n\ntargets:\n  build:\n    description: build from source code\n    cmds:\n      ./build.sh\n    artifacts:\n      out/service/Dockerfile\n      out/service/service.bin\n      out/service-compose/docker-compose.yml\n\n  pack:\n    description: pack as docker image\n    after:\n      build\n    build: out/service\n    image: 'myservice:latest'\n\n  start:\n    description: start built service in background\n    after:\n      pack\n    compose: out/service-compose\n\n  test:\n    description: test against service\n    after:\n      start\n    link:\n      'service:service'\n    cmds:\n      ./test.sh\n\nIn the above example, target build builds from source code and generates\nDockerfile for pack, and docker-compose.yml for run.\nTarget pack creates a docker image using output from build.\nTarget start spawns the built service in the background using compose.\nAnd test runs tests against the started service.\n",
        "tags": []
    },
    {
        "uri": "/content/tutor/targetexp",
        "title": "Target Expansion",
        "content": "It's quite common targets are defined similarly with very small difference.\nFor example, a build target which builds for different CPU architectures,\nthe only difference can be the name passing to the build script.\n\n---\nformat: hypermake.v0\nname: expand-sample\n\ntargets:\n  hmake-linux-amd64:\n    description: static linked hmake binary for linux-amd64\n    after:\n      vendor\n    watches:\n      '*/*/*.go'\n      build.sh\n    cmds:\n      ./build.sh linux amd64\n    artifacts:\n      bin/linux/amd64/hmake\n      bin/hmake-linux-amd64.tar.gz\n      bin/hmake-linux-amd64.tar.gz.sha256sum\n\n  hmake-linux-arm:\n    description: static linked hmake binary for linux-arm\n    after:\n      vendor\n    watches:\n      '*/*/*.go'\n      build.sh\n    cmds:\n      ./build.sh linux arm\n    artifacts:\n      bin/linux/arm/hmake\n      bin/hmake-linux-arm.tar.gz\n      bin/hmake-linux-arm.tar.gz.sha256sum\n\n  hmake-linux-arm64:\n    description: static linked hmake binary for linux-arm64\n    after:\n      vendor\n    watches:\n      '*/*/*.go'\n      build.sh\n    cmds:\n      ./build.sh linux arm64\n    artifacts:\n      bin/linux/arm64/hmake\n      bin/hmake-linux-arm64.tar.gz\n      bin/hmake-linux-arm64.tar.gz.sha256sum\n\nObviously, there are a lot of duplications in above sample.\nWith target expansion, the above targets can be rewritten as\n\n---\nformat: hypermake.v0\nname: expand-sample\n\ntargets:\n  hmake-linux-[arch:amd64,arm,arm64]:\n    description: static linked hmake binary for linux-$[arch]\n    after:\n      vendor\n    watches:\n      '*/*/*.go'\n      build.sh\n    cmds:\n      ./build.sh linux $[arch]\n    artifacts:\n      bin/linux/$[arch]/hmake\n      bin/hmake-linux-$[arch].tar.gz\n      bin/hmake-linux-$[arch].tar.gz.sha256sum\n\nIt's possible to use multiple expansion variables.\n",
        "tags": []
    },
    {
        "uri": "/content/tutor/wrappermode",
        "title": "Wrapper Mode",
        "content": "_I have a project using Makefile; I don't want to learn HyperMake. But building\nin container is very appealing to me._\n\nhmake provides a special wrapper mode for legacy projects.\n\nA Simple and Quick Start\n\necho 'hmake-wrapper gcc:4.9' HyperMake\n\nNow hmake becomes a wrapper of make\n\nhmake target1 target2\n\nis equivalent to\n\nmake target1 target2\n\nbut inside a container created from gcc:4.9.\n\nSpecification\n\nIn wrapper mode, HyperMake may contain one or more lines.\nThe first line has specific format:\n\nhmake-wrapper IMAGE [BUILD-FROM] [BUILD-ARG1] [BUILD-ARG2] ...\n\nIt must start with #hmake-wrapper,\nand IMAGE is required to specify a docker image.\n\nBUILD-FROM is optional, when present, hmake will create a toolchain target\nto build toolchain image for rest of other targets.\nIt specifies the location of Dockerfile.\nAnd the rest of parameters are interpreted as --build-args for docker build.\n\nIf there's only one line, hmake will invoke make with command line arguments.\nIf there're more lines:\n\nIf second line starts with #!,\n  all lines from second line are copied as a script,\n  and hmake invokes this script as build target;\nIf second line doesn't start with #!,\n  a line #!/bin/sh plus all lines from second line are copied as a script,\n  and hmake executes the script.\n\nExamples\n\nWraps over make\n\nhmake-wrapper gcc:4.9\n\nWraps over a python script\n\nhmake-wrapper python:2.7\n!/usr/bin/env python\nprint 'Hello'\n\nWraps over a shell script\n\nhmake-wrapper busybox\necho Hello\n",
        "tags": []
    }
]